# 1.线性结构(Linear List)

**线性结构是`由n(n≥0)数据元素(节点)`a[0]、a[1]、... 、a[n-1]、a[n]组成的`有限序列`**

**其中**

* 序列：有顺序的列表

* 数据元素的个数n定义为表的长度 = 'list'.length()   当'list'.length的长度是0的时候称为空表
* 将非空的线性表(n>=1)记作：a[0]、a[1]、... 、a[n-1]、a[n]
* 将数据元素a\[i](0≤i≤n-1)只是个抽象符号，具体含义再在不同情况下可以不同
  * i 可以是数字、对象、数组、字符串...

**常见的线性结构**

* **数组结构(Array)**
* **栈结构(Stack)**
* **队列结构(Queue)**
* **链表结构(LinkedList)**

## 1.1数组(Array)

* 数组的内存是连续的，所以在知道下标的情况下，访问效率非常的高
  * 早期的JavaScript数组的内存是不连续的，内存类似与链表

**缺点**

* 数组的创建通常需要`申请一段连续的内存空间`(一整块的内存)，并且大小是固定的(大多数编程语言数组都是固定的)，所以当当前数组`不能满足容量需求时`，需要`扩容`（一般情况下是申请一个更大的数组，比如2倍，然后将原数组的元素复制过去）
* 而且在`数组开头或中间位置插入`数据的`成本很高`，需要进行`大量的元素位移`
* 尽管JavaScript的Array底层可以帮我们做这些事情，但是背后的原理依然是这样·

## 1.2.栈结构(Stack)

* **栈，它是一种受限的线性结构，`后进先出(LIFO)`**
  * 其限制是`仅允许在表的一端`进行插入和删除操作。这一端被称之为`栈顶`，相对的，另一端称为`栈底`
  * 向一个栈插入新元素称之为进栈、入栈、压栈，那么这个新的元素就称为栈顶元素
  * 从一个栈删除元素称之为出栈、退栈

**栈常见的操作**

* **push(element)**: 添加一个新元素到栈顶位置
* **pop()**: 移除栈顶的元素，同时返回被移除的元素
* **peek()**: 返回栈顶的元素，不对栈做任何的修改（这个方法不会移除栈顶的元素，仅仅返回它）
* **isEmpty()**: 如果栈里面没有任何元素，返回true，反之返回false
* **size()**: 返回栈里的元素个数

**使用数组实现栈结构**

```typescript
// 基于数组的方式实现
class Stack<T = any> {
  // 定义一个数组，用于存储元素
  private data: any[] = [];

  // push 将一个元素压入栈
  push(element: T) {
    this.data.push(element);
  }

  // pop  将一个元素弹出栈
  pop(): T | undefined {
    return this.data.pop();
  }

  // peek 查看栈顶元素，只是查看
  peek(): T | undefined {
    return this.data[this.data.length - 1];
  }

  // isEmpty  判断栈是否为空
  isEmpy(): boolean {
    return this.data.length === 0;
  }

  // siz  返回栈的数据个数
  size(): number {
    return this.data.length;
  }
}
```

## 1.3.队列结构(Queue)

**队列是一种受限的线性表，`先进先出(FIFO)`**

* 受限之处在于它只允许在队列的`前端`进行`删除`操作
* 在队列的`后端`进行`插入`操作

  **队列常见的操作**

* **enqueue(element)**: 向队列尾部添加一个或多个新的项
* **dequeue()**：移除队列首部的项，并返回被移除的项
* **peek()/front()**: 返回队列的第一个(最先被加入的)元素，不对队列做任何的修改（这个方法不会移除队首的元素，仅仅返回它）
  * 有的语言中用peek 有的用front
* **isEmpty()**: 如果队列里面没有任何元素，返回true，反之返回false
* **size()**: 返回队列的元素个数



**使用数组实现队列**

```typescript

class Queue<T = any>  {
    // 保存数据
    private data: T[] = []

    enqueue(...element: T[]): void {
        this.data.push(...element)
    }

    dequeue(): T | undefined {
        return this.data.shift()
    }

    peek(): T | undefined {
        return this.data[0]
    }

    isEmpty(): boolean {
        return this.data.length === 0
    }

    // 使用计算属性，调用的时候 可以当作属性来用，可以少写一个括号
    get size(): number {
        return this.data.length
    }
}
```

## 1.4.链表结构(LinkedList)

**介绍**

* 要存储多个元素除了可以使用数组，还可以使用链表
* 不同于数组，链表的元素在内存中不必是连续的空间
  * 链表的每个元素`由一个存储元素本身的节点`和一个`指向下一个元素的引用`(有些语言称为指针或者链接)组成
* **相对于数组，链表的`优点`**
  * `内存空间不是必须连续的`
    * 可以充分的利用计算机的内存，实现灵活的`内存动态管理`
  * 链表`不必`在创建时就`确定大小`，并且大小可以`无限的延伸下去`
  * 链表在`插入和删除`数据时，`时间复杂度`可以达到O(1)
    * 相对于数组效率高很多
* **相对于数组，链表的`缺点`**
  * 链表访问任何一个位置的元素时，`都需从头开始访问`。(无法跳过第一个元素访问任何一个元素)
  * 无法通过下标直接访问元素，`都需要从头一个个访问`，直到找到对应的元素

**链表常见的操作**

* **append(element):** 向链表尾部添加一个新的项
* **insert(position, element):** 向链表的特定位置插入一个新的项
* **get(position):** 获取对应位置的元素
* **indexOf(element):** 返回元素在链表中的索引，如果链表中没有该元素则返回 -1
* **updata(position, element):** 修改某个位置的元素
* **removeAt(position):** 从链表的特定位置移除一项
* **remove(element):** 从链表中移除一项
* **isEmpty():** 如果链表中不包含任何元素，返回true，反之返回false
* **size():** 返回链表包含的元素个数   

```javascript
// 创建Node节点类
class Node<T = any> {
  item: T
  next: Node<T> | null = null
  constructor(item: T) {
    this.item = item
  }
}

// 创建linkedList类
class LinkedList<T> {
  private head: Node<T> | null = null
  private size: number = 0

  get length() {
    return this.size
  }

  // 私有方法 根据索引获取节点
  private getNode(position: number): Node<T> | null {
    let index = 0
    let current = this.head

    while (index++ < position && current) {
      current = current.next
    }
    return current
  }

  // 追加节点
  append(item: T) {
    const newNode = new Node<T>(item)

    this.size++
    // 判断  只有当head是空的时候才将节点给head
    // 反之则将新的节点给当前节点的最后一个节点的next
    if (!this.head) return (this.head = newNode)

    let current = this.head
    while (current.next) {
      current = current.next
    }

    current.next = newNode
  }

  // 遍历链表
  traverse() {
    let values: any[] = []
    let current = this.head
    while (current) {
      values.push(current.item)
      current = current.next
    }
    console.log(`%c ${values.join('=>')}`, 'color: #bada55')
  }

  /**
   * 插入方法
   * @param item 要插入的元素
   * @param position 插入的位置
   */

  /*
    0.首先要做边界判断，插入的下标不能是负数或者大于当前链表的个数
    1.判断插入的下标是否是0 如果是那么就在头部插入
    2.反之 以下步骤
    3.插入的核心就是拿到被插入位置的前一个节点和后一个节点
    4.将前一个节点的next指向插入的新的节点
    5.将插入的新的节点的next指向后一个节点
  */
  insert(item: T, position: number): boolean {
    const newNode = new Node<T>(item)

    // 边界判断
    if (position < 0 || position > this.size) return false

    // 判断是否是头部添加
    if (position === 0) {
      newNode.next = this.head
      this.head = newNode
    } else {
      let previous = this.getNode(position - 1)

      newNode.next = previous!.next
      previous!.next = newNode
    }
    this.size++
    return true
  }

  /**
   * 删除指定位置的节点
   * @param position 要删除的下标
   * @returns
   */

  /*
    1.首先是要做边界判断，删除的下标不可是负数或者大于等于当前链表的size，因为下标 是从0开始
    2.判断插入的下标是否是0 如果是那么就在头部删除(就是将head指向head.next)
    3.反之 以下步骤 
    4.删除的核心就是找到当前要删除的下标对应的节点前一个节点和后一个节点
    5.然后让前一个节点的next指向后一个节点，那么此时当前要删除的元素就没有被元素指向了，就会被GC回收

  */
  removeAt(position: number): T | null {
    // 越界判断
    if (position < 0 || position >= this.size) return null

    let current = this.head
    if (position === 0) {
      this.head = current?.next ?? null
    } else {
      let previous = this.getNode(position - 1)
      current = previous?.next ?? null
      previous!.next = previous?.next?.next ?? null
    }
    this.size--
    return current?.item ?? null
  }

  // 根据value删除
  remove(value: T): T | null {
    const index = this.indexOf(value)
    return this.removeAt(index)
  }

  /**
   * 根据下标获取节点
   * @param position 要获取节点的下标
   * @returns
   */
  get(position: number): T | null {
    // 越界判断
    if (position < 0 || position >= this.size) return null

    return this.getNode(position)?.item ?? null
  }

  /**
   * 修改
   * @param value 要修改的内容
   * @param position 节点索引
   * @returns boolean
   */
  update(value: T, position: number): boolean {
    // 越界判断
    if (position < 0 || position >= this.size) return false

    // 上面做过边界判断 此时的current 一定有值

    let current = this.getNode(position) as Node<T>
    current.item = value

    return true
  }

  /**
   * 根据内容查找索引
   * @param value 查找索引的值
   * @returns
   */
  indexOf(value: T): number {
    let index = 0
    let current = this.head
    while (current) {
      if (current.item === value) {
        return index
      }
      current = current.next
      index++
    }
    return -1
  }

  isEmpty(): boolean {
    return this.size === 0
  }
}
```

## 1.5.哈希表结构(HashTable)

[GitHub笔记好心人整理的](https://github.com/XPoet/js-data-structures-and-algorithms/blob/master/assets/doc/10_JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%8D%81%EF%BC%89%E5%93%88%E5%B8%8C%E8%A1%A8.md)

### 1.5.1.哈希表的介绍

* 几乎所有的编程语言都有直接或者间接的应用这种数据结构
* 哈希表通常是`基于数组进行实现的`，但是相对于数组，它有`很多优势`
  * 它可以提供非常快速的`插入-删除-查找操作`
  * 无论多少数据，插入和删除值都是接近常量的时间，即O(1)的时间复杂度。实际上，只需`几个机器指令`即可完成
  * 哈希表的速度比`树还要快`，基本可以`瞬间查找到想要的元素`
  * 哈希表相对于树来说编码要容易很多
* 哈希表相对于数组的一些不足
  * 哈希表中的数据是`没有顺序`的，所以不能以一种固定的方式(比如从小到大)来遍历其中 的元素（没有特殊处理情况下）
  * 通常情况下，哈希表中的key是`不允许重复`的，不能放置相同的key，用于保存不同的元素

### 1.5.2.哈希表中的概念

* **哈希化**
  * 将`大数字`转化为`数组范围内下标(小数字)`的过程
* **哈希函数**
  * 通常将`单词`转成`大数字`，大数字再进行`哈希化`的代码实现放在一个函数中
* **哈希表**
  * 最终将数据插入到的这个`数组`，对整个结构的封装，称之为哈希表

**解决冲突使用的是`链地址法`,开放地址法目前已经不常用了** 



### 1.5.3.哈希函数

* 好的哈希函数应该静可能让计算的过程变得简单，提高计算的效率
  * 提高速度的一个办法就是让哈希函数中`尽量少的有乘法和除法`，因为`他们的性能都是比较低的`





**好的哈希函数应该具备的优点**

* 快速的计算
  * 哈希表的优势在于效率，所以快速获取到对应的hashCode非常重要
  * 使用`霍纳算法来实现`
* 均匀的分布
  * 哈希表中，无论是链地址法还是开放地址法，当多个元素映射到同一个位置的时候，都会影响到效率
  * 所以优秀的哈希函数应尽可能将元素映射到不同的位置，让元素在哈希表中均匀分布





# 2.算法复杂度

##  2.1.大O表示法

**由来**



**大O表示法(Big O notation) 英文翻译为大O符号(维基百科翻译)，中文通常翻译为大O表示法（标记法）**

这个记号是在`德国数论学家`爱德蒙·兰道的著作中才推广的，因此它有时又称为`兰道符号`



**推导过程**



* 大O符号`在分析算法效率的时候非常有用`



* 举个例子，解决一个规模为n的问题所花费的时间（或者所需步骤的数目）可以表示为 T(n) = 4n² - 2n + 2

`当n增大时，n²项开始占主导位置，其它各项可以被忽略`



* 举个例子 当n=1000
  * 4n²项时2n的2000倍，因此在大多数场合下，省略后者对表达式的值的影响是可以忽略不计的
  * 进一步看，n²的系数也是无关紧要的
  * 这样`大O符号记下剩余部分`
  * `T(n) ∈ O(n²) `或 `T(n) = O(n²) `
* 我们就说该算法`具有n²阶（平方阶）的时间复杂度，表示O(n²) `

##  2.2.常见的对数阶

**常见的函数阶**



`顺序由上到下表示时间复杂度由低到高`

| 符号                 | 名称                                   | 举例                                                         |
| -------------------- | -------------------------------------- | ------------------------------------------------------------ |
| O(1)                 | `常数`(阶，下同)                       | 有一个函数，无论里面有多少步骤(除了遍历)，有固定的步骤，都算常量阶计作O(1) |
| O(log𝓷)              | `对数`                                 | 二分查找法                                                   |
| O(𝓷)                 | `线性`(次线性)                         | 随着n的增大而增大，比如顺序查找法，一般就是一层循环          |
| O(𝓷log𝓷)             | `线性对数`，或对数线性、拟线性、超线性 |                                                              |
| O(𝓷²)                | `平方`                                 | 一般就是循环中又嵌套一层循环                                 |
| O(𝓷ᶜ),Integer(c > 1) | `多项式`，有时叫作代数(阶)             | 一般就是循环中又嵌套c层循环`不推荐`                          |
| O(cⁿ)                | `指数`，有时叫作几何(阶)               | 这个比代数数阶更消耗性能，随着c的增大，整个函数呈几何增大 `不推荐` |

## 2.3.空间复杂度

* 空间复杂度指的是程序运行过程中所需要的额外存储空间
  * 空间复杂度也`可以用大O表示法来表示`
  * `空间复杂度的计算方法与时间复杂度类似`，通常需要分析程序中`需要额外分配的内存空间，如数组、变量、对象、递归调用`等
    * 比如一个程序中，多用了一个数据结构或一个数组（不需要这些多用的也可以执行程序），但是如果当前执行完毕后，用的变量、数组等被销毁了，其实是可以忽略不计的



* 举例说明

  * 对于一个简单的递归算法来说，每次调用都会在内存中分配新的栈帧，这些栈帧占用了额外的空间

    * 因此，该算法的空间复杂度是`O(𝓷)`，其中`n`是递归深度

  * 而对于`迭代算法`来说，在`每次迭代中不需要分配额外的空间`，因此其空间复杂度为`O(1)`

    

* 当空间复杂度很大时，可能会导致内存不足，程序奔溃

  

* 在平时进行算法优化时，通常进行如下的考虑

  * 使用尽量少的空间（优化空间复杂度）
  * 使用尽量少的时间（优化时间复杂度）
  * 特定情况下，使用`空间换时间`或使用`时间换空间`

## 2.4.数组和链表的复杂度对比

* `数组`是一种连续的存储结构，通过下标可以直接访问数组中的任意元素
  * `时间复杂度`：对于数组，随机访问时间复杂度为`O(1)`，插入和删除操作的时间复杂度为`O(n)`
  * `空间复杂度`：数组需要连续的存储空间，空间复杂度为`O(n)`
* `链表`是一种链式存储结构，通过指针链接起来的节点组成，访问链表中的元素需要从头节点开始遍历
  * `时间复杂度`：对于链表，随机访问的时间复杂度为`O(n)`，插入和删除操作的时间复杂度为`O(1)`
  * `空间复杂度`：链表需要为每个节点分配存储空间，空间复杂度为`O(n)`
* 在实际开发中，选择使用数组还是链表需要根据具体的应用场景来决定
  * 如果数据量不大，且需要频繁随机访问元素，使用数组可能会更好
  * 如果数据量大，或需要频繁的插入和删除元素，使用链表可能会更好

# 3.非线形结构

## 3.1.树结构(Tree)

[好心人整理的笔记](https://github.com/XPoet/js-data-structures-and-algorithms/blob/master/assets/doc/11_JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E6%A0%91.md)

### 3.1.1.什么是树

* 树是一种数据结构，像我们平时见到的族谱图，公司管理结构图都是树结构

* 树结构是模拟真实的树，只不过真实的树的根部在下面，而树结构的根部在上面，这是为了方便观看

* **树结构**

  * 树：由n( n≥0)个节点构成的有限集合，当n=0时，称为空树

  * 对于任意一棵非空树，它具备一下性质
    * 树种有一个为根(Root)的特殊节点，用`r`表示
    * 其余节点可分为m(m>0)个互不相交的有限集合T1，T2...Tm,其中每个集合本身又是一棵树，成为原来树的子树(SubTree)
  * 下图红色框就是集合，也可以成为子树

![](https://cdn.staticaly.com/gh/wscymdb/picx-images-hosting@master/algorithm/Snipaste_2023-06-02_09-43-49.63q7y7h434g0.jpeg)

### 3.1.2.树的特点

**这里用数组/链表/哈希表的特点来与树的特点做比较，这样很容易理解**



**以下的优缺点都不是特定的，比如数组和链表之间的比较，和，数组和哈希表直接的笔记也会有不同，目的是衬托出树的特点**



* **数组**
  * 优点：可以通过下标来访问，访问效率高等
  * 缺点：在非尾部修复值的情况下，效率低下等
* **链表**
  * 优点：修改数据的时候效率高等
  * 缺点：查找数据的时候要从头依次查找，效率低下等
* **哈希表**
  * 优点：哈希表的插入、删除、查询的效率都非常高等
  * 缺点：空间利用率不高，是无序的，不能快速的查处最值等
* **树**
  * 优点：树结构综合了上述三种数据结构的优点，同时也弥补了他们的不足。（虽然效率不一定都比他们高）。比如树结构中数据都是有序的，空间利用率高等
  * 缺点：树分很多中，每种树的缺点都不同

**总的来说没有完美的数据结构，每种数据结构都有自己特定的应用场景**



### 3.1.3.常用术语

![](https://cdn.staticaly.com/gh/wscymdb/picx-images-hosting@master/algorithm/Snipaste_2023-06-02_09-47-15.4c7otw7quua0.jpeg)

* `节点的度(Degree)`: 节点的子树个数，比如c节点的度就是2

* `树的度(Degree)`：一棵树中，最大的节点的度，如上图，树的度就是2

* `叶节点(Leaf)`(叶子节点): 度为0的节点，如上图所示

* `父节点(parent)`: 若一个节点含有子节点，则这个节点称为其子节点的父节点，如图 B节点是D和E的父节点

* `子节点(Child)`: 一个节点含有的子树的根节点称为该节点的子节点，如图D和E是B的子节点

* `兄弟节点(Sibling)`：具有相同父节点的节点互称为兄弟节点，如图 D和E是兄弟节点

* `路径和路径长度`：路径指的是一个节点到另一个节点的通道，路径长度就是需要多少步才能走到该节点，如图A到H的路径长度是3

* `节点的层次`：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；上图的树的层次是4，B、C节点层次是2

* `深度`：对于任意节点n,n的深度为从根到n的唯一路径长，根的深度为0，那么整棵树的深度就是该树中最深的节点。

  * 比如H的深度，从根出发走3步可以到达(不算根节点，因为根节点是0)，所以深度是3，整个树的最深的节点深度是3，所以该树的深度是3

  `高度`：对于任意节点n,n的高度为从n到一片树叶的最长路径长，所有树叶的高度为0

  * 比如：上图A节点的到最长的树叶的路径有三条H、I、J，选一条即可，那么从A到H的路径是3，需要走三步，所以A节点的高度是3，
  * 比如D节点的最长树叶路径是H那么，那么从D到H需要走一步，所以他的高度是1

### 3.1.4.树结构的表示方法

**最普通的表示方法**

![](https://cdn.staticaly.com/gh/wscymdb/picx-images-hosting@master/algorithm/Snipaste_2023-06-02_10-17-27.1zzor73x0v40.jpeg)

* 如图，树结构的组成方式类似于链表，都是由一个个节点连接构成。不过，根据每个父节点子节点数量的不同，每一个父节点需要的引用数量也不同。比如节点 A 需要 3 个引用，分别指向子节点 B，C，D；B 节点需要 2 个引用，分别指向子节点 E 和 F；K 节点由于没有子节点，所以不需要引用。

* 这种方法缺点在于我们无法确定某一结点的引用数。

**儿子-兄弟表示法**

![](https://cdn.staticaly.com/gh/wscymdb/picx-images-hosting@master/algorithm/Snipaste_2023-06-02_10-21-05.1d3jkxxn3uao.jpeg)

* 我们可以这样记录树每个节点的数据
* 每个节点只记录一个兄弟比如B节点有C、D俩兄弟，那么B只记录C，D由C记录
* `这种表示法的优点在于每一个节点中引用的数量都是确定的。`

```javascript
{value:A,sonNode:B,slibing：null}
{value:B,sonNode:E,slibing：C}
{value:C,sonNode:G,slibing：D}
...
```

### 3.1.5.二叉树

#### 3.1.5.1.概念

* 如果树中的`每一个节`点`最多只能有两个子节点`，这样的树就是二叉树	



* 二叉树可以为空树，也就是没有节点

#### 3.1.5.2.二叉树的五种形态

* 下图分别为：
  * a：空树
  * b：只有一个节点的二叉树
  * c：只有左子树的二叉树
  * d：只有右子树的二叉树
  * e：有左右子树的二叉树

![](https://cdn.staticaly.com/gh/wscymdb/picx-images-hosting@master/algorithm/Snipaste_2023-06-02_10-36-38.5gf0fq07a7c0.webp)

#### 3.1.5.3.二叉树的特性



* 一个二叉树的`第i层的最大节点数为`：2^(i-1)， i>=1   翻译：2的i-1次方
  * eg：下图的第三层最大节点数是4
* 深度`为k的二叉树的最大节点总数为`：2^k - 1, k >=1 
  * eg：下图这棵树的深度为4，那么它最多只能有2的4次方-1个节点 也就是15个节点
  * 假设这棵二叉树的深度为2，也就是只看前两层，那么最大节点为3
* 对于任何非空二叉树T，若n0表示叶子节点的个数，n2是度为2的非叶子节点的个数，那么两者`满足关系n0=n2+1`
  * 换句话来说一个非空二叉树的所有叶子节点的总数等于该数所有度为2的节点的总数+1
  * 如图 假如我们知道所有叶子节点（5个），那么就可以求出所有度为2的节点的总数（4个）。



![](https://cdn.staticaly.com/gh/wscymdb/picx-images-hosting@master/algorithm/Snipaste_2023-06-02_09-47-15.4c7otw7quua0.jpeg)

### 3.1.6.特殊二叉树

#### 3.1.6.1.完美二叉树

* 完美二叉树(Perfect Binary Tree)也称为满二叉树(Full Binary Tree)，`在二叉树中，除了最下层的叶子节点外，每层节点都有两个子节点`
* 言外之意就是最后一层必须为叶子节点，就是最后一层的所有子节点为0

![](https://cdn.staticaly.com/gh/wscymdb/picx-images-hosting@master/algorithm/Snipaste_2023-06-02_11-04-14.1beoyd4nfe3k.webp)

#### 3.1.6.2.完全二叉树

* 满足下列条件的称为完全二叉树(Complete Binary Tree)
  * `除了二叉树的最后一层，其他每层的节点都达到峰值`(每个节点都有两个子节点)
  * `且最后一层的叶子节点，从左往右是连续存在的，只是缺失了右侧的若干子节点`
    * 因为最后一层是叶子节点，对于完全二叉树来说，运行你的叶子节点不满，但是从左往右必须是连续的，缺失部分只能在右侧
* 完美二叉树是特殊的完全二叉树
* 下图就不是完全二叉树，因为不满足从左往右是连续的节点
* <img src="https://cdn.staticaly.com/gh/wscymdb/picx-images-hosting@master/algorithm/Snipaste_2023-06-02_11-15-20.5qq7yywvidg0.webp" />

### 3.1.7.二叉搜索树

#### 3.1.7.1.定义

* `二叉搜索树(Binary Search Tree,BST)`，也称为`二叉排序树`或`二叉查找树`
* **二叉搜索树也是一棵二叉树，可以为空树**
* 如果不为空，则需要**满足以下的性质**
  * 条件一：非空`左子树`的所有键值`小于`其根节点的键值
  * 条件二：非空`右子树`的所有键值`大于`其根节点的键值



* 下图《一》不是二叉搜索树，因为以10为根节点的所有节点可以看作是一棵子树，那么他的右子树应该大于10，但是5不大于10，所以不是
* 下图《二》，符合BST树，比如50是41节点子树的右侧大于41，50同时又是30节点的右侧，他也大于30
* 图《三》逻辑同图《二》



![](https://cdn.staticaly.com/gh/wscymdb/picx-images-hosting@master/algorithm/Snipaste_2023-06-08_09-07-43.2qjyx7er03o0.jpeg)

### 3.1.8.树的遍历

* 常见的树遍历有**四种方式**，这些遍历不仅仅适用二叉搜索树，适用所有的树
* **先序遍历(preOrderTraverse)**
* **中序遍历(inOrderTraverse)**
* **后续遍历(postOrderTraverse)**
* **层序遍历(levelOrderTraverse)**

#### 3.1.8.1.先序遍历

* 只要`有根节点`(每棵子节点如果有子节点，那么该节点也是一棵树)，那么就`优先遍历根节点`，然后才遍历左子节点和右子节点，这两个的顺序不打紧，但是通常来说是先遍历左节点，再遍历右节点

```javascript
1.首先打印的是11，因为11是根节点
2.走到左子树，以7为根的子树也是一棵树，所以打印7
3.走到左子树，以5为根的子树也是一棵树，所以打印5
4.走到左子树，以3为根的子树也是一棵树，所以打印3，
5.3没有子节点了，不往下走了，返回到5节点的右节点，6没有子节点，所以打印6
6.6没有子节点了，返回到7这棵树的右节点，以9为根的子树也是一棵树，所以打印9
7.走到左子树，打印8节点
8.8节点没有子节点，返回到9节点，走到9节点的右侧，打印10
9.11节点的左侧都打印完毕了，然后走到11节点的右侧，打印15
10.走到15节点的左侧 打印13
11.走到13节点的左侧 打印12
12.走到13节点的右侧 打印14
13.走到15节点的右侧 打印20
14.走到20节点的左侧 打印18
15.走到20节点的右侧 打印25

最终结果是：11，7，5，3，6，9，8，10，15，13，12，14，20，18，25

               11               
        ┌───────┴───────┐       
        7              15       
    ┌───┴───┐       ┌───┴───┐   
    5       9      13      20   
  ┌─┴─┐   ┌─┴─┐   ┌─┴─┐   ┌─┴─┐ 
  3   6   8  10  12  14  18  25 
```

#### 3.1.8.2.中序遍历

* 先遍历左子树或右子树都没关系(通常先遍历左子树，这样符合人的习惯)，只要保证根节点在这个两个中间遍历即可
* 中序遍历的思路是**，先遍历左子的最左侧节点，然后才遍历根节点，最后再遍历右子树的最右侧节点**

```javascript
 1.走到7节点,发现7还有节点，走到5，发现5还有节点，走到3，3没有节点，打印3
 2.打印3的根节点，5
 3.打印5的右侧，6
 4.打印5的根节点，打印7
 5.走到7的右侧9，发现9还有根节点，走到9的左侧，打印8
 6.打印8的根节点，9
 7.打印9的右侧，10
 8.打印7的根节点，11
 9.走到11的右侧，发现15有节点，走到15的左侧，发现13有节点，走到12，12没节点，打印12
 10.打印12的根节点，13
 11.打印13的右侧，14
 12.打印13的根节点，15
 13.走到15的右侧，20有节点18，18没有节点，打印18
 14.打印18的根节点，20
 15.打印20的右侧，25
 
 最终结果为：3，5，6，7，8，9，10，11，12，13，14，15，18，20，25

               11               
        ┌───────┴───────┐       
        7              15       
    ┌───┴───┐       ┌───┴───┐   
    5       9      13      20   
  ┌─┴─┐   ┌─┴─┐   ┌─┴─┐   ┌─┴─┐ 
  3   6   8  10  12  14  18  25 
```

#### 3.1.8.3.后序遍历

* 先遍历左子树或右子树都没关系(通常先遍历左子树，这样符合人的习惯)，只要保证根节点最后遍历即可
* 后序遍历的思路是，**先遍历左子的最左侧节点，然后再遍历右子树的最右侧节点，`最后`才遍历根节点**

```javascript
保证根节点是最后打印即可，具体步骤借鉴上面两个，字太多懒得打
1.打印3
2.打印6
3.打印5
4.打印8
5.打印10
6.打印9
7.打印7
8.打印12
9.打印14
10.打印13
11.打印18
12.打印25
13.打印20
14.打印15
15.打印11

最终结果：3 6 5 8 10 9 7  12 14 13 18 25 20 15 11

               11               
        ┌───────┴───────┐       
        7              15       
    ┌───┴───┐       ┌───┴───┐   
    5       9      13      20   
  ┌─┴─┐   ┌─┴─┐   ┌─┴─┐   ┌─┴─┐ 
  3   6   8  10  12  14  18  25 
```

#### 3.1.8.4.层序遍历

* 层序遍历：一层一层的遍历

```javascript
/**
   * 层序遍历：一层一层的遍历
   * 这里使用的是队列结构来解决
   * 核心思路是：先入队，再出队，在出队的过程中，然后判断出队节点是否有左(右)节点，如果有左(右)节点，将左(右)节点入队
   * 
   * 步骤如下
   * 先将11节点入队，打印11，然后将11节点出队，然后将11的左右节点入队
   * 利用队列先入先出的特性，此时队列第一位是7，第二位是15
   * 然后7出队，打印7，然后将7的左右节点入队，此时队列内容是15、5、9
   * 然后15出队，打印15，将15的左右节点入队，此时队列内容是5、9、13、20
   * 以此类推知道打印出最后一个元素
   *
   * 树结构如下
   *           11               
        ┌───────┴───────┐       
        7              15       
    ┌───┴───┐       ┌───┴───┐   
    5       9      13      20   
  ┌─┴─┐   ┌─┴─┐   ┌─┴─┐   ┌─┴─┐ 
  3   6   8  10  12  14  18  25 
   */
  levelOrderTraverse() {
    // 判断是否有根节点
    if (!this.root) return
    // 创建一个队列
    const quqeue: TreeNode<T>[] = [this.root]

    // 循环
    while (quqeue.length) {
      // 内进入这里说明队列是有值的，所以一定可以出队，所以做非空断言
      const current = quqeue.shift()!
      console.log(current.value)

      // 判断当前出队节点是否有左节点，如果有则入队
      if (current.left) quqeue.push(current.left)

      // 判断当前出队节点是否有右节点，如果有则入队
      if (current.right) quqeue.push(current.right)
    }
  }
```

