# 1.线性结构(Linear List)

**线性结构是`由n(n≥0)数据元素(节点)`a[0]、a[1]、... 、a[n-1]、a[n]组成的`有限序列`**

**其中**

* 序列：有顺序的列表

* 数据元素的个数n定义为表的长度 = 'list'.length()   当'list'.length的长度是0的时候称为空表
* 将非空的线性表(n>=1)记作：a[0]、a[1]、... 、a[n-1]、a[n]
* 将数据元素a\[i](0≤i≤n-1)只是个抽象符号，具体含义再在不同情况下可以不同
  * i 可以是数字、对象、数组、字符串...

**常见的线性结构**

* **数组结构(Array)**
* **栈结构(Stack)**
* **队列结构(Queue)**
* **链表结构(LinkedList)**

## 1.1数组(Array)

* 数组的内存是连续的，所以在知道下标的情况下，访问效率非常的高
  * 早期的JavaScript数组的内存是不连续的，内存类似与链表

**缺点**

* 数组的创建通常需要`申请一段连续的内存空间`(一整块的内存)，并且大小是固定的(大多数编程语言数组都是固定的)，所以当当前数组`不能满足容量需求时`，需要`扩容`（一般情况下是申请一个更大的数组，比如2倍，然后将原数组的元素复制过去）
* 而且在`数组开头或中间位置插入`数据的`成本很高`，需要进行`大量的元素位移`
* 尽管JavaScript的Array底层可以帮我们做这些事情，但是背后的原理依然是这样·

## 1.2.栈结构(Stack)

* **栈，它是一种受限的线性结构，`后进先出(LIFO)`**
  * 其限制是`仅允许在表的一端`进行插入和删除操作。这一端被称之为`栈顶`，相对的，另一端称为`栈底`
  * 向一个栈插入新元素称之为进栈、入栈、压栈，那么这个新的元素就称为栈顶元素
  * 从一个栈删除元素称之为出栈、退栈

**栈常见的操作**

* **push(element)**: 添加一个新元素到栈顶位置
* **pop()**: 移除栈顶的元素，同时返回被移除的元素
* **peek()**: 返回栈顶的元素，不对栈做任何的修改（这个方法不会移除栈顶的元素，仅仅返回它）
* **isEmpty()**: 如果栈里面没有任何元素，返回true，反之返回false
* **size()**: 返回栈里的元素个数

**使用数组实现栈结构**

```typescript
// 基于数组的方式实现
class Stack<T = any> {
  // 定义一个数组，用于存储元素
  private data: any[] = [];

  // push 将一个元素压入栈
  push(element: T) {
    this.data.push(element);
  }

  // pop  将一个元素弹出栈
  pop(): T | undefined {
    return this.data.pop();
  }

  // peek 查看栈顶元素，只是查看
  peek(): T | undefined {
    return this.data[this.data.length - 1];
  }

  // isEmpty  判断栈是否为空
  isEmpy(): boolean {
    return this.data.length === 0;
  }

  // siz  返回栈的数据个数
  size(): number {
    return this.data.length;
  }
}
```

## 1.3.队列结构(Queue)

**队列是一种受限的线性表，`先进先出(FIFO)`**

* 受限之处在于它只允许在队列的`前端`进行`删除`操作
* 在队列的`后端`进行`插入`操作

  **队列常见的操作**

* **enqueue(element)**: 向队列尾部添加一个或多个新的项
* **dequeue()**：移除队列首部的项，并返回被移除的项
* **peek()/front()**: 返回队列的第一个(最先被加入的)元素，不对队列做任何的修改（这个方法不会移除队首的元素，仅仅返回它）
  * 有的语言中用peek 有的用front
* **isEmpty()**: 如果队列里面没有任何元素，返回true，反之返回false
* **size()**: 返回队列的元素个数



**使用数组实现队列**

```typescript

class Queue<T = any>  {
    // 保存数据
    private data: T[] = []

    enqueue(...element: T[]): void {
        this.data.push(...element)
    }

    dequeue(): T | undefined {
        return this.data.shift()
    }

    peek(): T | undefined {
        return this.data[0]
    }

    isEmpty(): boolean {
        return this.data.length === 0
    }

    // 使用计算属性，调用的时候 可以当作属性来用，可以少写一个括号
    get size(): number {
        return this.data.length
    }
}
```

## 1.4.链表结构(LinkedList)

**介绍**

* 要存储多个元素除了可以使用数组，还可以使用链表
* 不同于数组，链表的元素在内存中不必是连续的空间
  * 链表的每个元素`由一个存储元素本身的节点`和一个`指向下一个元素的引用`(有些语言称为指针或者链接)组成
* **相对于数组，链表的`优点`**
  * `内存空间不是必须连续的`
    * 可以充分的利用计算机的内存，实现灵活的`内存动态管理`
  * 链表`不必`在创建时就`确定大小`，并且大小可以`无限的延伸下去`
  * 链表在`插入和删除`数据时，`时间复杂度`可以达到O(1)
    * 相对于数组效率高很多
* **相对于数组，链表的`缺点`**
  * 链表访问任何一个位置的元素时，`都需从头开始访问`。(无法跳过第一个元素访问任何一个元素)
  * 无法通过下标直接访问元素，`都需要从头一个个访问`，直到找到对应的元素

**链表常见的操作**

* **append(element):** 向链表尾部添加一个新的项
* **insert(position, element):** 向链表的特定位置插入一个新的项
* **get(position):** 获取对应位置的元素
* **indexOf(element):** 返回元素在链表中的索引，如果链表中没有该元素则返回 -1
* **updata(position, element):** 修改某个位置的元素
* **removeAt(position):** 从链表的特定位置移除一项
* **remove(element):** 从链表中移除一项
* **isEmpty():** 如果链表中不包含任何元素，返回true，反之返回false
* **size():** 返回链表包含的元素个数   

```javascript
// 创建Node节点类
class Node<T = any> {
  item: T
  next: Node<T> | null = null
  constructor(item: T) {
    this.item = item
  }
}

// 创建linkedList类
class LinkedList<T> {
  private head: Node<T> | null = null
  private size: number = 0

  get length() {
    return this.size
  }

  // 私有方法 根据索引获取节点
  private getNode(position: number): Node<T> | null {
    let index = 0
    let current = this.head

    while (index++ < position && current) {
      current = current.next
    }
    return current
  }

  // 追加节点
  append(item: T) {
    const newNode = new Node<T>(item)

    this.size++
    // 判断  只有当head是空的时候才将节点给head
    // 反之则将新的节点给当前节点的最后一个节点的next
    if (!this.head) return (this.head = newNode)

    let current = this.head
    while (current.next) {
      current = current.next
    }

    current.next = newNode
  }

  // 遍历链表
  traverse() {
    let values: any[] = []
    let current = this.head
    while (current) {
      values.push(current.item)
      current = current.next
    }
    console.log(`%c ${values.join('=>')}`, 'color: #bada55')
  }

  /**
   * 插入方法
   * @param item 要插入的元素
   * @param position 插入的位置
   */

  /*
    0.首先要做边界判断，插入的下标不能是负数或者大于当前链表的个数
    1.判断插入的下标是否是0 如果是那么就在头部插入
    2.反之 以下步骤
    3.插入的核心就是拿到被插入位置的前一个节点和后一个节点
    4.将前一个节点的next指向插入的新的节点
    5.将插入的新的节点的next指向后一个节点
  */
  insert(item: T, position: number): boolean {
    const newNode = new Node<T>(item)

    // 边界判断
    if (position < 0 || position > this.size) return false

    // 判断是否是头部添加
    if (position === 0) {
      newNode.next = this.head
      this.head = newNode
    } else {
      let previous = this.getNode(position - 1)

      newNode.next = previous!.next
      previous!.next = newNode
    }
    this.size++
    return true
  }

  /**
   * 删除指定位置的节点
   * @param position 要删除的下标
   * @returns
   */

  /*
    1.首先是要做边界判断，删除的下标不可是负数或者大于等于当前链表的size，因为下标 是从0开始
    2.判断插入的下标是否是0 如果是那么就在头部删除(就是将head指向head.next)
    3.反之 以下步骤 
    4.删除的核心就是找到当前要删除的下标对应的节点前一个节点和后一个节点
    5.然后让前一个节点的next指向后一个节点，那么此时当前要删除的元素就没有被元素指向了，就会被GC回收

  */
  removeAt(position: number): T | null {
    // 越界判断
    if (position < 0 || position >= this.size) return null

    let current = this.head
    if (position === 0) {
      this.head = current?.next ?? null
    } else {
      let previous = this.getNode(position - 1)
      current = previous?.next ?? null
      previous!.next = previous?.next?.next ?? null
    }
    this.size--
    return current?.item ?? null
  }

  // 根据value删除
  remove(value: T): T | null {
    const index = this.indexOf(value)
    return this.removeAt(index)
  }

  /**
   * 根据下标获取节点
   * @param position 要获取节点的下标
   * @returns
   */
  get(position: number): T | null {
    // 越界判断
    if (position < 0 || position >= this.size) return null

    return this.getNode(position)?.item ?? null
  }

  /**
   * 修改
   * @param value 要修改的内容
   * @param position 节点索引
   * @returns boolean
   */
  update(value: T, position: number): boolean {
    // 越界判断
    if (position < 0 || position >= this.size) return false

    // 上面做过边界判断 此时的current 一定有值

    let current = this.getNode(position) as Node<T>
    current.item = value

    return true
  }

  /**
   * 根据内容查找索引
   * @param value 查找索引的值
   * @returns
   */
  indexOf(value: T): number {
    let index = 0
    let current = this.head
    while (current) {
      if (current.item === value) {
        return index
      }
      current = current.next
      index++
    }
    return -1
  }

  isEmpty(): boolean {
    return this.size === 0
  }
}
```

## 1.5.哈希表结构(HashTable)

# 2.算法复杂度

##  2.1.大O表示法

**由来**



**大O表示法(Big O notation) 英文翻译为大O符号(维基百科翻译)，中文通常翻译为大O表示法（标记法）**

这个记号是在`德国数论学家`爱德蒙·兰道的著作中才推广的，因此它有时又称为`兰道符号`



**推导过程**



* 大O符号`在分析算法效率的时候非常有用`



* 举个例子，解决一个规模为n的问题所花费的时间（或者所需步骤的数目）可以表示为 T(n) = 4n² - 2n + 2

`当n增大时，n²项开始占主导位置，其它各项可以被忽略`



* 举个例子 当n=1000
  * 4n²项时2n的2000倍，因此在大多数场合下，省略后者对表达式的值的影响是可以忽略不计的
  * 进一步看，n²的系数也是无关紧要的
  * 这样`大O符号记下剩余部分`
  * `T(n) ∈ O(n²) `或 `T(n) = O(n²) `
* 我们就说该算法`具有n²阶（平方阶）的时间复杂度，表示O(n²) `

##  2.2.常见的对数阶

**常见的函数阶**



`顺序由上到下表示时间复杂度由高到低`

| 符号                 | 名称                                   | 举例                                                         |
| -------------------- | -------------------------------------- | ------------------------------------------------------------ |
| O(1)                 | `常数`(阶，下同)                       | 有一个函数，无论里面有多少步骤(除了遍历)，有固定的步骤，都算常量阶计作O(1) |
| O(log𝓷)              | `对数`                                 | 二分查找法                                                   |
| O(𝓷)                 | `线性`(次线性)                         | 随着n的增大而增大，比如顺序查找法，一般就是一层循环          |
| O(𝓷log𝓷)             | `线性对数`，或对数线性、拟线性、超线性 |                                                              |
| O(𝓷²)                | `平方`                                 | 一般就是循环中又嵌套一层循环                                 |
| O(𝓷ᶜ),Integer(c > 1) | `多项式`，有时叫作代数(阶)             | 一般就是循环中又嵌套c层循环`不推荐`                          |
| O(cⁿ)                | `指数`，有时叫作几何(阶)               | 这个比代数数阶更消耗性能，随着c的增大，整个函数呈几何增大 `不推荐` |

## 2.3.空间复杂度

* 空间复杂度指的是程序运行过程中所需要的额外存储空间
  * 空间复杂度也`可以用大O表示法来表示`
  * `空间复杂度的计算方法与时间复杂度类似`，通常需要分析程序中`需要额外分配的内存空间，如数组、变量、对象、递归调用`等
    * 比如一个程序中，多用了一个数据结构或一个数组（不需要这些多用的也可以执行程序），但是如果当前执行完毕后，用的变量、数组等被销毁了，其实是可以忽略不计的



* 举例说明

  * 对于一个简单的递归算法来说，每次调用都会在内存中分配新的栈帧，这些栈帧占用了额外的空间

    * 因此，该算法的空间复杂度是`O(𝓷)`，其中`n`是递归深度

  * 而对于`迭代算法`来说，在`每次迭代中不需要分配额外的空间`，因此其空间复杂度为`O(1)`

    

* 当空间复杂度很大时，可能会导致内存不足，程序奔溃

  

* 在平时进行算法优化时，通常进行如下的考虑

  * 使用尽量少的空间（优化空间复杂度）
  * 使用尽量少的时间（优化时间复杂度）
  * 特定情况下，使用`空间换时间`或使用`时间换空间`

## 2.4.数组和链表的复杂度对比

* `数组`是一种连续的存储结构，通过下标可以直接访问数组中的任意元素
  * `时间复杂度`：对于数组，随机访问时间复杂度为`O(1)`，插入和删除操作的时间复杂度为`O(n)`
  * `空间复杂度`：数组需要连续的存储空间，空间复杂度为`O(n)`
* `链表`是一种链式存储结构，通过指针链接起来的节点组成，访问链表中的元素需要从头节点开始遍历
  * `时间复杂度`：对于链表，随机访问的时间复杂度为`O(n)`，插入和删除操作的时间复杂度为`O(1)`
  * `空间复杂度`：链表需要为每个节点分配存储空间，空间复杂度为`O(n)`
* 在实际开发中，选择使用数组还是链表需要根据具体的应用场景来决定
  * 如果数据量不大，且需要频繁随机访问元素，使用数组可能会更好
  * 如果数据量大，或需要频繁的插入和删除元素，使用链表可能会更好
