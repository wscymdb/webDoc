# 1.线性结构(Linear List)

**线性结构是`由n(n≥0)数据元素(节点)`a[0]、a[1]、... 、a[n-1]、a[n]组成的`有限序列`**

**其中**

* 序列：有顺序的列表

* 数据元素的个数n定义为表的长度 = 'list'.length()   当'list'.length的长度是0的时候称为空表
* 将非空的线性表(n>=1)记作：a[0]、a[1]、... 、a[n-1]、a[n]
* 将数据元素a\[i](0≤i≤n-1)只是个抽象符号，具体含义再在不同情况下可以不同
  * i 可以是数字、对象、数组、字符串...

**常见的线性结构**

* **数组结构(Array)**
* **栈结构(Stack)**
* **队列结构(Queue)**
* **链表结构(LinkedList)**

## 1.1数组(Array)

* 数组的内存是连续的，所以在知道下标的情况下，访问效率非常的高
  * 早期的JavaScript数组的内存是不连续的，内存类似与链表

**缺点**

* 数组的创建通常需要`申请一段连续的内存空间`(一整块的内存)，并且大小是固定的(大多数编程语言数组都是固定的)，所以当当前数组`不能满足容量需求时`，需要`扩容`（一般情况下是申请一个更大的数组，比如2倍，然后将原数组的元素复制过去）
* 而且在`数组开头或中间位置插入`数据的`成本很高`，需要进行`大量的元素位移`
* 尽管JavaScript的Array底层可以帮我们做这些事情，但是背后的原理依然是这样·

## 1.2.栈结构(Stack)

* **栈，它是一种受限的线性结构，`后进先出(LIFO)`**
  * 其限制是`仅允许在表的一端`进行插入和删除操作。这一端被称之为`栈顶`，相对的，另一端称为`栈底`
  * 向一个栈插入新元素称之为进栈、入栈、压栈，那么这个新的元素就称为栈顶元素
  * 从一个栈删除元素称之为出栈、退栈

**栈常见的操作**

* **push(element)**: 添加一个新元素到栈顶位置
* **pop()**: 移除栈顶的元素，同时返回被移除的元素
* **peek()**: 返回栈顶的元素，不对栈做任何的修改（这个方法不会移除栈顶的元素，仅仅返回它）
* **isEmpty()**: 如果栈里面没有任何元素，返回true，反之返回false
* **size()**: 返回栈里的元素个数

**使用数组实现栈结构**

```typescript
// 基于数组的方式实现
class Stack<T = any> {
  // 定义一个数组，用于存储元素
  private data: any[] = [];

  // push 将一个元素压入栈
  push(element: T) {
    this.data.push(element);
  }

  // pop  将一个元素弹出栈
  pop(): T | undefined {
    return this.data.pop();
  }

  // peek 查看栈顶元素，只是查看
  peek(): T | undefined {
    return this.data[this.data.length - 1];
  }

  // isEmpty  判断栈是否为空
  isEmpy(): boolean {
    return this.data.length === 0;
  }

  // siz  返回栈的数据个数
  size(): number {
    return this.data.length;
  }
}
```

## 1.3.队列结构(Queue)

**队列是一种受限的线性表，`先进先出(FIFO)`**

* 受限之处在于它只允许在队列的`前端`进行`删除`操作
* 在队列的`后端`进行`插入`操作

  **队列常见的操作**

* **enqueue(element)**: 向队列尾部添加一个或多个新的项
* **dequeue()**：移除队列首部的项，并返回被移除的项
* **peek()/front()**: 返回队列的第一个(最先被加入的)元素，不对队列做任何的修改（这个方法不会移除队首的元素，仅仅返回它）
  * 有的语言中用peek 有的用front
* **isEmpty()**: 如果队列里面没有任何元素，返回true，反之返回false
* **size()**: 返回队列的元素个数



**使用数组实现队列**

```typescript

class Queue<T = any>  {
    // 保存数据
    private data: T[] = []

    enqueue(...element: T[]): void {
        this.data.push(...element)
    }

    dequeue(): T | undefined {
        return this.data.shift()
    }

    peek(): T | undefined {
        return this.data[0]
    }

    isEmpty(): boolean {
        return this.data.length === 0
    }

    // 使用计算属性，调用的时候 可以当作属性来用，可以少写一个括号
    get size(): number {
        return this.data.length
    }
}
```

## 1.4.链表结构(LinkedList)

**介绍**

* 要存储多个元素除了可以使用数组，还可以使用链表
* 不同于数组，链表的元素在内存中不必是连续的空间
  * 链表的每个元素`由一个存储元素本身的节点`和一个`指向下一个元素的引用`(有些语言称为指针或者链接)组成
* **相对于数组，链表的`优点`**
  * `内存空间不是必须连续的`
    * 可以充分的利用计算机的内存，实现灵活的`内存动态管理`
  * 链表`不必`在创建时就`确定大小`，并且大小可以`无限的延伸下去`
  * 链表在`插入和删除`数据时，`时间复杂度`可以达到O(1)
    * 相对于数组效率高很多
* **相对于数组，链表的`缺点`**
  * 链表访问任何一个位置的元素时，`都需从头开始访问`。(无法跳过第一个元素访问任何一个元素)
  * 无法通过下标直接访问元素，`都需要从头一个个访问`，直到找到对应的元素

