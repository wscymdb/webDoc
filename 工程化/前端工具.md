# 1.自动化工具Gulp

## 1.1.定义

* **一个工具包，可以帮你自动化和增加你的工作流;**
* 慢慢退出历史舞台，学习一下思想，了解一下，技多不压身

## 1.2.Gulp和webpack的区别

* gulp的核心理念是**task runner**
  * 可以定义自己的一系列任务，等待任务被执行; 
  *  基于文件Stream的构建流;
  * 我们可以使用gulp的插件体系来完成某些任务;

* webpack的核心理念是**module bundler**
  *  webpack是一个模块化的打包工具;
  * 可以使用各种各样的loader来加载不同的模块;
  * 可以使用各种各样的插件在webpack打包的生命周期完成其他的任务;

* **gulp相对于webpack的优缺点:**
  * gulp相对于webpack思想更加的简单、易用，更适合编写一些自动化的任务;
  * 但是目前对于大型项目(Vue、React、Angular)并不会使用gulp来构建，比如默认gulp是不支持模块化的;

## 1.3.Gulp的使用

* 安装
  * `npm i gulp `
* 编写一个`gulpfile.js`文件，在其中编写任务
* 执行`npx gulp 任务名` 命令

```javascript
function foo1(cb) {
  console.log('这是我的第一个gulp任务')
  cb()
}

const series1 = series(foo1, foo2)

module.exports = {
  foo1
}

// 终端中输入 npx gulp foo1
```

## 1.4.创建Gulp任务

* 每个gulp任务**都是一个异步的JavaScript函数:**
  * 每个任务都必须要被结束，否则报错
  * 此函数可以`接受一个callback作为参数`，调用`callback`函数那么任务会结束;
  * 或者是一个`返回stream、promise、event emitter、child process或observable类型的函数`，来结束任务
* 任务可以是public或者private类型的:
  * **公开任务(Public tasks)** 从 gulpfile 中被导出(export)，可以通过 gulp 命令直接调用
  * **私有任务(Private tasks)** 被设计为在内部使用，通常作为 series() 或 parallel() 组合的组成部分;

```javascript
// 这个任务被导出了 所以是公开任务
function foo1(cb) {
  console.log('这是我的第一个gulp任务')
  cb()
}

// 这个任务没有被导出，是石油任务
function foo2(cb) {
  console.log('这是foo2--gulp任务')
  cb()
}

module.exports = {
  foo1
}

```

## 1.5.默认任务

* 在终端中执行 npx gulp ，即使后面不跟任务名，也会执行的任务

```javascript
function foo1(cb) {
  console.log('这是我的第一个gulp任务')
  cb()
}

//  默认任务
exports.default = foo1
```

## 1.6.任务组合

* 通常一个函数中能完成的任务是有限的(放到一个函数中也不方便代码的维护)，所以我们会将任务进行组合
* **gulp**提供了两个强大的组合方法:
  * `series`：串行任务组合
    * 会等待上一个任务执行完毕后，才执行下一个任务
  * `parallel`：并行任务组合
    * 所有任务一起执行

```javascript
const { series, parallel } = require('gulp')

function foo1(cb) {
  setTimeout(() => {
    console.log('这是我的第一个gulp任务')
    cb()
  }, 2000)
}

function foo2(cb) {
  setTimeout(() => {
    console.log('这是foo2--gulp任务')
    cb()
  }, 3000)
}


// 串行任务
const series1 = series(foo1, foo2)

// 并行任务
const parallel1 = parallel(foo1, foo2)
module.exports = {
  series1,
  parallel1,
}

```

## 1.7.读取和写入文件

* **gulp 暴露了 src() 和 dest() 方法用于处理计算机上存放的文件**
  * `src(x)`用于匹配x中的文件，然后生成一个`Node流`，然后将这个流返回
  * `dest()接受一个输出目录作为参数`，并且它还会产生一个 Node流(stream)，通过该流将内容输出到文件中;
* **流(stream)所提供的主要的** **API** **是** **.pipe()** **方法，pipe方法的原理是什么呢?**
  * pipe方法是node中的一个方法
  * pipe方法接受一个`转换流(Transform streams)`或`可写流(Writable streams)`;
  * 那么转换流或者可写流，拿到数据之后可以对数据进行处理，再次传递给下一个`转换流或者可写流`;

```javascript
const { src, dest } = require('gulp')

// 复制文件
//  src, dest返回的是一个流 也用于结束当前任务
function copyFile(cb) {
  return src('./src/**/*.js').pipe(dest('./dist'))
}

module.exports = {
  copyFile,
}

```

## 1.8.文件的转化

* 比如我们打包文件，需要将es6的代码转换es5，并且压缩代码
* 那么就需要用到插件
* gulp插件地址：https://gulpjs.com/plugins/
* pipe中的各种函数会自动获取到上一个pipe处理过的值

```javascript
const { src, dest } = require('gulp')
const babel = require('gulp-babel')
const terser = require('gulp-terser')

const jsTask = () => {
  return src('./src/**/*.js')
    .pipe(babel({ presets: ['@babel/preset-env'] }))
    .pipe(terser())
    .pipe(dest('./dist'))
}

module.exports = {
  jsTask,
}
```

## 1.9.Gulp的文件监听

* 当我们修改过某个文件之后，然后需要手动的执行任务
* 如果修改的过于频繁，那么每次手动操作很麻烦
* 所以可以使用gulp提供的`watch方法`
* 当要监听的文件发生变化，自动执行方法

```javascript
const { src, dest, watch } = require('gulp')
const babel = require('gulp-babel')
const terser = require('gulp-terser')

const jsTask = () => {
  return src('./src/**/*.js')
    .pipe(dest('./dist'))
}

// 监听文件的变化，自动调用任务
// 避免改动某个文件 再手动执行任务
//watch(监听目录, 方法名)
watch('./src/**/*.js', jsTask)

module.exports = {
  jsTask,
}
```

# 2.库打包工具rollup

## 2.1.认识rollup

* **定义**
  * rollup是一个Javascript的模块化打包工具，可以帮助我们编译小的代码到一个大的、复杂的代码中，比如一个库或者一个应用程序
* **Rollup和webpack的区别**
  * Rollup`也是一个模块化的打包工具`，但是Rollup`主要针对ES Module`进行打包的
  * 另外webpack通常可以通过各种的loader来处理各种各样的文件，以及处理他们的依赖关系
  * rollup`处理文件`都是使用`插件`来完成的
  * rollup更多的时候是`专注于javascript的处理`（当然也可以处理css、font、vue等文件）
  * 另外rollup的`配置理念相对于webpack`来说，`更加简洁和容易理解`
  * 早期的时候webpack是不具备tree shaking，但是rollup具备
* **目前webpack和rollup的应用场景**
  * 通常`在实际项目开发过程中`，我们都会`使用webpack`
  * 在`对库文件进行打包时`，通常`使用rollup`，（比如vue、react、dayjs源码本身都是基于rollup，Vite底层也是使用Rollup）
    * 一般来说开发一个框架或者库用到的会比较多

## 2.2.基本使用

* **安装**

  * `npm i rollup -D `

* **打包环境**

  * rollup可以打包运行在不同环境的包，比如运行在浏览器的包，运行在nodejs的包等
  * 只需要在执行的时候 `-f 环境名`即可

* **命令行中使用**

  * ```
    # 打包浏览器的库
    npx rollup 输入路径 -f iife -o 输出路径
    eg: npx rollup ./src/main.js -f iife -o dist/bundle.js
    
    # 打包AMD的库
    npx rollup ./src/main.js -f amd -o dist/bundle.js
    
    # 打包CommonJS的库
    npx rollup ./src/main.js -f cjs -o dist/bundle.js
    
    # 打包通用的库(必须跟上name)
    # 其实这个name就是打包在浏览器环境中放在window的对象名 eg:window.mathUtil
    npx rollup ./src/main.js -f umd --name mathUtil -o dist/bundle.js
    ```

  * 

## 2.3.rollup配置文件

```javascript
module.exports = {
  // 入口
  input: './lib/index.js',

  // 出口
  output: {
    format: 'umd', // 打包的环境
    name: 'myUtil', // 使用umd必须要有name 这样打包到浏览器中这个名字就会作为全局的变量
    file: './dist/bundle.js', // 打包文件到哪里
    globals: {
      lodash: '_',
      dayjs: 'dayjs',
    },
  },

  // 出口也可使一个数组  可以打包多个环境的包
  // output: [
  //   {
  //     format: 'cjs',
  //     name: 'myUtil',
  //     file: './dist/bundle.cjs.js',
  //   },
  //   {
  //     format: 'iife',
  //     name: 'myUtil',
  //     file: './dist/bundle.browser.js',
  //   },
  // ],
}

```



## 2.4.解决commonjs和三方库的问题

* `默认情况`下rollup只处理`es module`，那么如果我们使用的三方库使用的是commonjs导出方式，那么就不会打包使用的三方库
* **例子**
  * `案例一`比如引入了lodash，但是lodash使用的是commonjs的导出方式，打包的时候就不会打包lodash，那么使用的时候就会报错
  * `案例二`再或者，我们自己编写了一个文件使用的是cjs的方式导出，但是导入的时候使用的是es的方式，那么就会报错
* **解决**
  * 如果是`案例二`：那么只需要借助下面的插件即可
    * `npm install @rollup/plugin-commonjs -D `
    * 这个插件可以帮助我们在cjs和es之间相互转换
  * 如果是`案例一`，那么`还需要`借助下面这个插件
    * `npm install @rollup/plugin-node-resolve -D`
    * 这个插件帮助我们解析引入node_modules中的三方库路径的问题
* 

```javascript
// 默认情况下rollup只会处理es module  但是引用了lodash lodash使用的是common js 所以要借助插件来解决

const commonjs = require('@rollup/plugin-commonjs')
const noderesolve = require('@rollup/plugin-node-resolve')

module.exports = {
  // 入口
  input: './lib/index.js',

  // 出口
  output: {
    format: 'umd', // 打包的环境
    name: 'myUtil', // 使用umd必须要有name 这样打包到浏览器中这个名字就会作为全局的变量
    file: './dist/bundle.js', // 打包文件到哪里
    // 创建 iife 或 umd 格式的 bundle 时，你需要通过 output.globals 选项来提供全局变量名称，以替换外部引入
    globals: {
      lodash: '_',
      dayjs: 'dayjs',
    },
  },
    external: ['lodash'], // 忽略打包某个库 这时候要提醒使用者安装这个库才能正常使用我们的库或框架
  plugins: [commonjs(), noderesolve()],
}

```

## 2.5.代码转换

* **rollup中处理文件都是使用插件来完成的**
* **rollup插件查询地址：**https://github.com/rollup/awesome
* terser官网文档没更新 使用`npm i @rollup/plugin-terser`

```javascript
// 默认情况下rollup只会处理es module  但是引用了lodash lodash使用的是common js 所以要借助插件来解决

const commonjs = require('@rollup/plugin-commonjs')
const noderesolve = require('@rollup/plugin-node-resolve')
const babel = require('@rollup/plugin-babel')
const terser = require('@rollup/plugin-terser')

module.exports = {
  // 入口
  input: './lib/index.js',

  // 出口
  output: {
    format: 'umd', // 打包的环境
    name: 'myUtil', // 使用umd必须要有name 这样打包到浏览器中这个名字就会作为全局的变量
    file: './dist/bundle.js', // 打包文件到哪里
    // 创建 iife 或 umd 格式的 bundle 时，你需要通过 output.globals 选项来提供全局变量名称，以替换外部引入
    globals: {
      lodash: '_',
      dayjs: 'dayjs',
    },
  },
  external: ['lodash'], // 忽略打包某个库 这时候要提醒使用者安装这个库才能正常使用我们的库或框架
  plugins: [
    commonjs(),
    noderesolve(),
    babel({ presets: ['@babel/preset-env'] }), // babel配置也可以单独放在一个配置文件 同webpack一样
    terser(),
  ],

}

```

## 2.6.处理css文件

* 这里使用postcss
* `yarn add postcss rollup-plugin-postcss --dev `

```javascript
const postcss = require('rollup-plugin-postcss')

module.exports = {
  // 入口
  input: './src/index.js',

  // 出口
  output: {
    format: 'iife', // 打包的环境
    name: 'myUtil', // 使用umd必须要有name 这样打包到浏览器中这个名字就会作为全局的变量
    file: './dist/bundle.js',
  },
  plugins: [
    postcss({
      plugins: [require('postcss-preset-env')], // 也可以单独放到一个配置文件中配置
    }),
  ],

}

```

## 2.7.处理vue文件

* 使用的是rollup-plugin-vue插件
* `npm i rollup-plugin-vue`
* 但是打包后浏览器运行会报错
  * 因为vue打包的时候会用到 process.env.NODE_ENV 所以在打包后的源码中添加这个变量
* 还需要借助@rollup/plugin-replace插件
* `npm install @rollup/plugin-replace -D `

```javascript
const vue = require('rollup-plugin-vue')
const replace = require('@rollup/plugin-replace')

module.exports = {
  // 入口
  input: './src/index.js',

  // 出口
  output: {
    format: 'iife', // 打包的环境
    name: 'myUtil', // 使用umd必须要有name 这样打包到浏览器中这个名字就会作为全局的变量
    file: './dist/bundle.js', // 打包文件到哪里

  },
  plugins: [
    vue(),
    // vue打包的时候会用到 process.env.NODE_ENV 所以在打包后的源码中添加这个变量
    // 如果是 'production'  解析的时候会将引号去掉，那么就是production  会报错因为没有定义这个变量  所以要 `'production'` 即使引号去掉了也还是一个字符串
    replace({
      'process.env.NODE_ENV': `'production'`,
    }),
  ],
}

```

## 2.8.搭建本地服务器

* **步骤一**：使用rollup-plugin-serve搭建服务
  * `npm i rollup-plugin-serve -D `
* **步骤二**：文件发生变化，自动刷新浏览器
  * `npm install rollup-plugin-livereload -D`
* **步骤三**：启动命令 -w是watch的简写
  * `npx rollup -c  -w`

```javascript
const server = require('rollup-plugin-serve')
const livereload = require('rollup-plugin-livereload')

module.exports = {
  // 入口
  input: './src/index.js',

  // 出口
  output: {
    format: 'iife', // 打包的环境
    name: 'myUtil', // 使用umd必须要有name 这样打包到浏览器中这个名字就会作为全局的变量
    file: './dist/bundle.js', // 打包文件到哪里
  },
  plugins: [
    server({
      port: 8888,
      open: true,
      contentBase: '.', // 启动文件夹 展示那个文件夹下的文件
    }),
    livereload(),
  ],
}
```



## 2.9.区分开发环境

* 比如我们在开发环境中是不需要压缩代码的，那么我们如何判断是开发还是生产环境呢？
* 在执行命令的时候加上` --environment NODE_ENV:production`
  * `eg: rollup -c --environment NODE_ENV:production`
* 那么在配置文件中可以通过`process.env.NODE_ENV`可以拿到`production这个值`

```javascript
const commonjs = require('@rollup/plugin-commonjs')
const noderesolve = require('@rollup/plugin-node-resolve')
const babel = require('@rollup/plugin-babel')
const terser = require('@rollup/plugin-terser')
const postcss = require('rollup-plugin-postcss')
const server = require('rollup-plugin-serve')
const livereload = require('rollup-plugin-livereload')

const isProd = process.env.NODE_ENV

const plugins = [
  commonjs(),
  noderesolve(),
  babel({ presets: ['@babel/preset-env'] }), // babel配置也可以单独放在一个配置文件 同webpack一样

  postcss({
    plugins: [require('postcss-preset-env')], // 也可以单独放到一个配置文件中配置
  }),
]
// 区分环境 比如开发环境不需要压缩代码
if (isProd) {
  plugins.push(terser())
} else {
  const extraPlugins = [
    server({
      port: 8888,
      open: true,
      contentBase: '.', // 启动文件夹 展示那个文件夹下的文件
    }),
    livereload(),
  ]
  plugins.push(...extraPlugins)
}

module.exports = {
  // 入口
  input: './src/index.js',

  // 出口
  output: {
    format: 'iife', // 打包的环境
    name: 'myUtil', // 使用umd必须要有name 这样打包到浏览器中这个名字就会作为全局的变量
    file: './dist/bundle.js', // 打包文件到哪里
    // 创建 iife 或 umd 格式的 bundle 时，你需要通过 output.globals 选项来提供全局变量名称，以替换外部引入
    globals: {
      lodash: '_',
      dayjs: 'dayjs',
    },
  },
  plugins,

}

```



