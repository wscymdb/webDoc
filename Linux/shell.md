# 1 shell基础

* shell是一个命令行解释器，它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序
* 用户可以用Shell来启动、挂起、停止或编写一些程序
* Shell还是一个功能相当强大的编程语言，易编写，易调试，灵活性较强
* Shell是解释执行的脚本语言，在Shell中可以直接调用Linux的系统命令



## 1.1 echo

* 输出命令 类似js的console.log
* `-e`：激活转义符选项

```shell
# 输出hello
echo hello

# 添加-e 像\t \e这些都会被转义

# 下面输出结果是 a 换行之后输出 b
echo -e "a\nb"

# 下面输出结果是 a\nb 直接输出内容不会转义
echo "a\nb"
```

## 1.2 编写执行shell脚本

* shell脚本是以`.sh`结尾的文件
* 脚本文件内容必须以`#!/bin/bash`开头
* 执行文件使用 `sh 文件名`
* 不能直接以`./文件名`执行，因为默认创建的文件是没有执行权限的，需要`手动添加执行权限`才能这样执行

**举例**

```shell
# 编写一个 hello.sh文件
#!/bin/bash
echo hello
echo -e "a\tb"

# 执行
sh hello.sh
```

## 1.3 alias

* 此命令是用来`临时`给一个命令`起别名的`，当窗口关闭就会失效
* 删除别名使用`unalias 别名`即可

**案例**

```shell
# 想要给ls -a起一个别名为ls
# 这样只需输入 la 就相当于输入ls -a命令了
alias la="ls -a"


```



**永久生效方法**

* 想要永久生效需要修改`~/.bashrc`配置文件

**案例**

```shell
# 永久添加一个la别名 他表示的是ls -a命令
vi ~/.bashrc
# 然后添加如下命令
alias la="ls -a"

# 然后保存，然后输入如下命令使配置文件生效
source ~/.bashrc
#或者输入以下命令也可使配置文件生效
. ~/.bashrc
```

## 1.4 命令生效的顺序

**当在shell中输入命令按照以下的顺序查找**

* 绝对路径或相对路径
  * 比如输入/usr/bin/ls和ls这个命令的效果是一样的
* 别名
* bash内部的命令
* 按照`$PATH`环境变量定义的目录查找
  * $PATH中会定义几个目录
  * 查找的时候如果第一目录找不到就往后找，找到了就不往后继续找了

## 1.5 命令快捷键

| 命令   | 含义                       |
| ------ | -------------------------- |
| ctrl+c | 强制终止当前命令           |
| ctrl+l | 清屏，效果同clear命令      |
| ctrl+a | 光标移动到命令行首         |
| ctrl+e | 光标移动到命令行尾         |
| ctrl+u | 从光标所在的位置删除到行首 |

## 1.6 历史命令

**语法**

```shell
history [选项] [历史命令保存的文件]
```



**选项**

* -c 清空历史命令
* -w 把缓存中的历史命令写入对应的文件中一般是`~/.bash_history`

**案例**

```shell
# 查看所有的历史命令
history

# 清空历史命令
history -c

# 当我们在shell中输入过的命令 这些命令会在窗口关闭之后自动保存在~/.bash_history文件中
# 如果想要立马将命令保存进去输入下面的命令
history -w ~/.bash_history

# 或者想要将历史命令保存到别的文件中
history -w a.txt
```

## 1.7 调用 

* 使用该命令可以`执行历史命令中的某个命令`，历史命令中每条命令都有一个ID
* 使用`!n`执行历史命令中`第n条`(命令对应的数字)命令
* 使用`!!`执行上一条命令
* 使用`!字符`重复执行最后一条以该字符串开头的命令
* 在shell中输入`!`加上面说的规则，然后`回车`即可

**举例**

```shell
# 假设历史命令有如下几条
  991  ls
  992  touch a.txt
  993  clear
  994  ls
  995  vi a.txt 
  996  vi b.txt
  
# 执行第993条命令 命令行输入如下命令 然后和回车 就会继续执行第993条命令,也就是clear命令
!993

## 执行上一条命令，也就是vi b.txt
!!

# 执行vi命令
# 输入以下命令 会在历史命令中找到最后一个以v开头的命令 也就是vi b.txt这条命令 
!v 
```

## 1.8 输入输出重定向

* stdin 全拼 standard input(标准输入)
* stdout 全拼 standard out(标准输出)
* stderr 全拼 standard error(标准错误)

### 1.8.1 基本概念

* **标准输出（stdout）**：默认情况下，命令的输出会显示在屏幕上。这称为标准输出，通常`文件描述符为 1`。
* **标准错误（stderr）**：命令的错误消息默认情况下也显示在屏幕上。这称为标准错误，通常`文件描述符为 2`。
  * 比如输入`ls kk`这个命令，会报错 ，这就是标准错误

* **标准输入（stdin）**：命令的输入默认从键盘获取。这称为标准输入，通常`文件描述符为 0`。



### 1.8.2 输出重定向

#### 1.8.2.1  重定向符号

- 下面的都是，文件不存在将创建文件
- `>`：将标准输出重定向到一个文件。如果文件存在，将覆盖该文件。
- `>>`：将标准输出追加到一个文件末尾。如果文件不存在，将创建该文件。
- `2>`：将标准错误重定向到一个文件。如果文件存在，将覆盖该文件。
- `2>>`：将标准错误追加到一个文件末尾。如果文件不存在，将创建该文件。
- `&>`：将标准输出和标准错误一起重定向到一个文件。
- `&>>`：将标准输出和标准错误一起追加到一个文件末尾。

#### 1.8.2.2 常见用法示例

1. **将输出重定向到文件**：

   ```shell
   # 这会将 `ls` 命令的输出重定向到 `output.txt` 文件中。
   ls > output.txt
   ```

2. **将输出追加到文件**：

   ```shell
   # 这会将 `echo` 命令的输出追加到 `output.txt` 文件中，而不是覆盖它。
   echo "Hello, World!" >> output.txt
   ```

3. **将错误消息重定向到文件**：

   ```shell
   # 这会将 `ls` 命令的错误消息重定向到 `error.txt` 文件中。
   ls nonexistentfile 2> error.txt
   ```

   

4. **将输出和错误消息都重定向到同一个文件**：

   ```shell
   # 这会将 `ls` 命令的输出和错误消息都重定向到 `all_output.txt` 文件中。
   
   # 命令1
   ls > all_output.txt 2>&1
   
   # 命令2
   ls &> all_output.txt
   
   # 两个命令的作用都是相同的
   # 命令2 比较好理解  &> 表示将标准输出和标准错误一起重定向到一个文件 
   # 所以命令2就是ls命令无论是错或是对都重定向到all_output.txt中
   
   # 命令2是一个组合命令
   # 2>&1：将标准错误重定向到标准输出的位置。由于标准输出已经被重定向到 all_output.txt 文件，所以标准错误也会被重定向到同一个文件。
   # &1：表示将标准错误重定向到与标准输出相同的位置。 可以理解为引用标准输出的位置 在这个例子中也就是all_output.txt
   # 如果你只是使用 ls > all_output.txt，那么只有标准输出会被重定向到 all_output.txt，而标准错误仍然会显示在终端上。通过添加 2>&1，你确保标准错误也被重定向到同一个文件中，这样所有输出（包括错误消息）都记录在 all_output.txt 中。
   ```

5. **将命令的输出作为输入传递给另一个命令**：

   ```shell
   # 这会将 `ls` 命令的输出通过管道传递给 `grep` 命令，`grep` 会搜索包含 `pattern` 的行。
   ls | grep "pattern"
   ```

#### 1.8.2.3 示例应用

假设你想将一个程序的标准输出和标准错误都重定向到一个文件，你可以这样做：

```shell
./myprogram > output.txt 2>&1
```

或者更简单地使用 `&>`：

```shell
./myprogram &> output.txt
```

这样，程序的所有输出（包括错误消息）都会被记录到 `output.txt` 文件中。



### 1.8.3 标准输入的重定向

标准输入重定向允许你从文件或其他命令获取输入，而不是从键盘。常见的重定向操作符有：

- `<`：将标准输入重定向到一个文件。
- `<<`：将标准输入重定向到一个内联文档（heredoc）。
- `<<<`：将标准输入重定向到一个字符串（这里文档）。

#### 1.8.3.1 常见用法示例

1. **将文件作为标准输入**：

   ```shell
   command < inputfile
   ```

   例如，使用 `cat` 命令读取 `file.txt` 的内容：

   ```shell
   # 这与 `cat file.txt` 的效果相同，都是将 `file.txt` 的内容显示在终端上。
   cat < file.txt
   ```

2. **使用管道将一个命令的输出作为另一个命令的输入**：

   ```
   command1 | command2
   ```

   例如，将 `ls` 命令的输出传递给 `grep` 命令：

   ```shell
   # 这会在当前目录中搜索包含 `pattern` 的文件或目录。
   ls | grep "pattern"
   ```

   

3. **使用内联文档（heredoc）**：

   ```shell
   command << delimiter
   text
   delimiter
   ```

   例如，使用 `cat` 命令创建一个包含多行文本的文件：

   ```shell
   cat <<EOF > myfile.txt
   This is a line of text.
   This is another line of text.
   EOF
   ```

   这会将多行文本写入 `myfile.txt` 文件中，直到遇到 `EOF` 作为结束标志。

4. **使用字符串作为输入（here string）**：

   ```shell
   command <<< "string"
   ```

   例如，将字符串传递给 `wc` 命令以计算单词数量：

   ```shell
   wc -w <<< "Hello, world!"
   ```

   这会输出 `2`，表示字符串 "Hello, world!" 有两个单词。

#### 1.8.3.2  实际应用

假设你有一个需要从文件读取输入的命令，可以这样使用标准输入重定向：

1. **从文件读取输入**：

   ```shell
   sort < unsorted.txt
   ```

   这会将 `unsorted.txt` 文件的内容作为输入传递给 `sort` 命令，并输出排序后的结果。

2. **通过管道传递输入**：

   ```shell
   ps aux | grep "firefox"
   ```

   这会列出所有运行的进程，然后过滤出包含 "firefox" 的进程信息。

3. **内联文档创建文件**：

   ```shell
   cat <<EOF > example.txt
   Line 1
   Line 2
   Line 3
   EOF
   ```

   这会将多行文本写入 `example.txt` 文件中。

#### 1.8.3.3 总结

标准输入是命令读取数据的主要来源，默认是从键盘接收输入。通过重定向操作符 `<`、`<<` 和 `<<<`，可以将文件、字符串或其他命令的输出作为输入传递给命令，使得命令行操作更加灵活和强大。

## 1.9 多命令执行顺序

* 声明多个命令直接该怎么执行

| 多命令执行符 | 格式             | 作用                                                   | 案例              |
| ------------ | ---------------- | ------------------------------------------------------ | ----------------- |
| ;            | 命令1;命令2      | 多个命令执行，命令直接没有任何逻辑关系                 | echo 1;echo2      |
| &&           | 命令1 && 命令2   | 逻辑与，只有命令1执行正确才会执行命令2                 | echo 1 && echo2   |
| \|\|         | 命令1 \|\| 命令2 | 逻辑或，命令1执行失败会执行命令2，反之则 不会执行命令2 | echo 1 \|\| echo2 |

**举例**

```shell
# 使用;符号，即使前面的命令报错了也会执行后面的命令，因为命令之间没有任何关系
ls kk; echo 2

#  逻辑与操作 和js差不多
echo 1 && echo 2

#  逻辑或操作 和js差不多
echo 1 || echo 2
```

## 1.10 管道符号

* 符号为：`|` 
* `｜前`的命令的`执行结果`会作为`｜之后`命令的`输入`

**案例**

```shell
# 假设1.txt有两行 第一行是123 第二行是456
# cat 1.txt的结果会作为 tail -1的输入
# 结果就是显示456
cat 1.txt | tail -1
```

## 1.11 通配符

| 通配符 | 作用                                                 |
| ------ | ---------------------------------------------------- |
| ?      | 匹配一个任意字符                                     |
| *      | 匹配0个或多可任意字符                                |
| []     | 匹配中括号中的任意一个                               |
| [-]    | 匹配中括号中的范围任意一个 eg:[0-9]匹配0-9中任意一个 |
| [^]    | 匹配不是中括号中的任意字符                           |

## 1.12 其他符号

| 符号  | 作用                                                         |
| ----- | ------------------------------------------------------------ |
| ''    | 单引号，在单引号中所有特殊符号，如`$`和`` `都没有特殊含义    |
| ""    | 双引号，在双引号中所有特殊符号都没有特殊含义，但是$  `  \这3个例外，拥有调用变量的值，引用命令和转义的含义 |
| \` \` | 反引号，括起来的是系统命令                                   |
| $()   | 和反引号一样                                                 |
| #     | 在shell脚本中，#开头的行代表注释                             |
| $     | 用于调用变量的值                                             |
| \     | 转义符号                                                     |

**举例**

```shell
# 输出结果就是$PATH
echo '$PATH'

# 输出结果 PATH这个变量的值 也就是当前系统环境变量有哪些
echo "$PATH"

# 输出 ls这个系统命令的执行结果
echo `ls`

```

# 2 变量

## 2.1 变量命名规则

* 必须以字母或下划线开头，名字中间只能由字母，数字和下划线组成
* 变量名的长度不得超过255个字符
* 变量名在有效范围内必须唯一
* 变量`默认类型都是字符串`

## 2.2 变量的类型

* 字符串
* 整型
* 浮点型
* 日期型

## 2.3 用户自定义变量

* 变量名不能以数字开头
* 等号左右两边不能有空格

### **定义变量**

```shell
# 注意 虽然age的值是10 但是他的类型依然是字符串类型
name="zs"
age=10
```

### **输出变量**

* 使用`$`调用变量

```shell
echo $name
echo $age
```

### **值默认都是字符串**

```shell
x=1
y=2
z=$x+$y

# 输出的结果是 1+2 所以可以证明值默认是字符串类型
echo $z

```

### 在赋值的时候引用变量

```shell
# 可以在双引号中之间调用变量
# 也可以使用 ${x} 调用变量 
x=123
y="$x"4
z=0${x}
```

### set

* 查询系统中默认所有已生效的变量，包括系统变量、环境变量，也包括自定义的变量

```shell
set

# 只查询有name的变量
set | grep name
```

### unset

* 删除变量
* unset 变量名

```shell
# 删除name这个变量
unset name
```

## 2.4 环境变量

* 环境变量是`全局变量`，自定义变量是`局部变量`
* `自定义变量`会在`当前shell中生效`，而环`境变量`会在`当前shell以及其子shell中生效`
  * 在shell中输入`bash`命令即可进入一个子shell
* 这种变量主要保存的是和系统操作环境相关的数据
* 环境变量可以自定义，但是`对系统生效的环境变量名`和`变量作用是固定的`

### 自定义环境变量

* 使用export关键字 `export 变量名=变量值`
* 这种方式只能临时创建系统变量，当shell关闭或者新打开一个shell就会没了
* 想要永久生效，需要修改文件

```shell
export name=zs
```

### env

* 仅仅用来查看环境变量，而看不到本地变量

```shell
# 查看所有的环境变量
env

# 查看环境变量中name相关的环境变量
env | grep name
```

### 常见的环境变量

| 变量名     | 含义                                                         |
| ---------- | ------------------------------------------------------------ |
| HOSTNAME   | 主机名                                                       |
| SHELL      | 当前的shell,LINUX中的终端有很多种,这个命令就是查看当前用的哪一种终端 |
| HISTSIZE   | 历史命令条数                                                 |
| SSH_CLIENT | 当前操作环境如果是用ssh连接的话，这里会记录客户端的IP        |
| USER       | 当前登录的用户                                               |

```shell
echo $HOSTNAME
echo $SHELL
echo $HISTSIZE
echo $SSH_CLIENT
echo $USER
```

### PATH

* `系统搜索的路径`
* 具体看上面`命令生效顺序章节`

```shell
 echo $PATH
 /root/.nvm/versions/node/v16.15.1/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin
```

**如何可以让一个自定义的脚本可以直接执行**

```shell
# 现在有hello.sh这个脚本 想让他在全局任意位置可以执行
# 也就是直接输入hello.sh可直接执行

# 方式一
# 把这个文件拷贝到 $PATH的其中任意目录下
# 比如/root/bin
# 原理：这个命令执行的顺序是从$PATH这一堆路径中查找的，找到了就执行


# 方式二 
# 把脚本文件所在的目录添加到PATH变量中
# 假如这个脚本文件在 /root/shells下面
# 注意linux中路径直接到分隔符用 :
export PATH="$PATH":/root/shells
```

### 语系环境变量

* 查询当前系统语系
* 在Linux中通过`locale命令`来设置程序运行的不同语言环境
* locale由ANSI C提供支持
* `LANG：定义系统主语系的变量`

```shell
# locale的命令规则为<语言>_<地区>.<字符集编码>
# 如 zh_CN.UTF-8
# zh表示中文。CN表示大陆地区 UTF-8表示字符集

# 查询当前系统语系
locale

# 查询当前系统主语系
echo $LANG
```

### 中文支持

* 图像界面可以支持中文
* 第三方工具比如xshell语系设置正确可以支持中文
* 虚拟机中纯字符界面不支持中文
