# 1 shell基础

* shell是一个命令行解释器，它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序
* 用户可以用Shell来启动、挂起、停止或编写一些程序
* Shell还是一个功能相当强大的编程语言，易编写，易调试，灵活性较强
* Shell是解释执行的脚本语言，在Shell中可以直接调用Linux的系统命令



## 1.1 echo

* 输出命令 类似js的console.log
* `-e`：激活转义符选项

```shell
# 输出hello
echo hello

# 添加-e 像\t \e这些都会被转义

# 下面输出结果是 a 换行之后输出 b
echo -e "a\nb"

# 下面输出结果是 a\nb 直接输出内容不会转义
echo "a\nb"
```

## 1.2 编写执行shell脚本

* shell脚本是以`.sh`结尾的文件
* 脚本文件内容必须以`#!/bin/bash`开头
* 执行文件使用 `sh 文件名`
* 不能直接以`./文件名`执行，因为默认创建的文件是没有执行权限的，需要`手动添加执行权限`才能这样执行

**举例**

```shell
# 编写一个 hello.sh文件
#!/bin/bash
echo hello
echo -e "a\tb"

# 执行 使用sh 进行执行
sh hello.sh
```

## 1.3 alias

* 此命令是用来`临时`给一个命令`起别名的`，当窗口关闭就会失效
* 删除别名使用`unalias 别名`即可

**案例**

```shell
# 想要给ls -a起一个别名为ls
# 这样只需输入 la 就相当于输入ls -a命令了
alias la="ls -a"


```



**永久生效方法**

* 想要永久生效需要修改`~/.bashrc`配置文件

**案例**

```shell
# 永久添加一个la别名 他表示的是ls -a命令
vi ~/.bashrc
# 然后添加如下命令
alias la="ls -a"

# 然后保存，然后输入如下命令使配置文件生效
source ~/.bashrc
#或者输入以下命令也可使配置文件生效
. ~/.bashrc
```

## 1.4 命令生效的顺序

**当在shell中输入命令按照以下的顺序查找**

* 绝对路径或相对路径
  * 比如输入/usr/bin/ls和ls这个命令的效果是一样的
* 别名
* bash内部的命令
* 按照`$PATH`环境变量定义的目录查找
  * $PATH中会定义几个目录
  * 查找的时候如果第一目录找不到就往后找，找到了就不往后继续找了

## 1.5 命令快捷键

| 命令   | 含义                       |
| ------ | -------------------------- |
| ctrl+c | 强制终止当前命令           |
| ctrl+l | 清屏，效果同clear命令      |
| ctrl+a | 光标移动到命令行首         |
| ctrl+e | 光标移动到命令行尾         |
| ctrl+u | 从光标所在的位置删除到行首 |

## 1.6 历史命令

**语法**

```shell
history [选项] [历史命令保存的文件]
```



**选项**

* -c 清空历史命令
* -w 把缓存中的历史命令写入对应的文件中一般是`~/.bash_history`

**案例**

```shell
# 查看所有的历史命令
history

# 清空历史命令
history -c

# 当我们在shell中输入过的命令 这些命令会在窗口关闭之后自动保存在~/.bash_history文件中
# 如果想要立马将命令保存进去输入下面的命令
history -w ~/.bash_history

# 或者想要将历史命令保存到别的文件中
history -w a.txt
```

## 1.7 调用 

* 使用该命令可以`执行历史命令中的某个命令`，历史命令中每条命令都有一个ID
* 使用`!n`执行历史命令中`第n条`(命令对应的数字)命令
* 使用`!!`执行上一条命令
* 使用`!字符`重复执行最后一条以该字符串开头的命令
* 在shell中输入`!`加上面说的规则，然后`回车`即可

**举例**

```shell
# 假设历史命令有如下几条
  991  ls
  992  touch a.txt
  993  clear
  994  ls
  995  vi a.txt 
  996  vi b.txt
  
# 执行第993条命令 命令行输入如下命令 然后和回车 就会继续执行第993条命令,也就是clear命令
!993

## 执行上一条命令，也就是vi b.txt
!!

# 执行vi命令
# 输入以下命令 会在历史命令中找到最后一个以v开头的命令 也就是vi b.txt这条命令 
!v 
```

## 1.8 输入输出重定向

* stdin 全拼 standard input(标准输入)
* stdout 全拼 standard out(标准输出)
* stderr 全拼 standard error(标准错误)

### 1.8.1 基本概念

* **标准输出（stdout）**：默认情况下，命令的输出会显示在屏幕上。这称为标准输出，通常`文件描述符为 1`。
* **标准错误（stderr）**：命令的错误消息默认情况下也显示在屏幕上。这称为标准错误，通常`文件描述符为 2`。
  * 比如输入`ls kk`这个命令，会报错 ，这就是标准错误

* **标准输入（stdin）**：命令的输入默认从键盘获取。这称为标准输入，通常`文件描述符为 0`。



### 1.8.2 输出重定向

#### 1.8.2.1  重定向符号

- 下面的都是，文件不存在将创建文件
- `>`：将标准输出重定向到一个文件。如果文件存在，将覆盖该文件。
- `>>`：将标准输出追加到一个文件末尾。如果文件不存在，将创建该文件。
- `2>`：将标准错误重定向到一个文件。如果文件存在，将覆盖该文件。
- `2>>`：将标准错误追加到一个文件末尾。如果文件不存在，将创建该文件。
- `&>`：将标准输出和标准错误一起重定向到一个文件。
- `&>>`：将标准输出和标准错误一起追加到一个文件末尾。

#### 1.8.2.2 常见用法示例

1. **将输出重定向到文件**：

   ```shell
   # 这会将 `ls` 命令的输出重定向到 `output.txt` 文件中。
   ls > output.txt
   ```

2. **将输出追加到文件**：

   ```shell
   # 这会将 `echo` 命令的输出追加到 `output.txt` 文件中，而不是覆盖它。
   echo "Hello, World!" >> output.txt
   ```

3. **将错误消息重定向到文件**：

   ```shell
   # 这会将 `ls` 命令的错误消息重定向到 `error.txt` 文件中。
   ls nonexistentfile 2> error.txt
   ```

   

4. **将输出和错误消息都重定向到同一个文件**：

   ```shell
   # 这会将 `ls` 命令的输出和错误消息都重定向到 `all_output.txt` 文件中。
   
   # 命令1
   ls > all_output.txt 2>&1
   
   # 命令2
   ls &> all_output.txt
   
   # 两个命令的作用都是相同的
   # 命令2 比较好理解  &> 表示将标准输出和标准错误一起重定向到一个文件 
   # 所以命令2就是ls命令无论是错或是对都重定向到all_output.txt中
   
   # 命令2是一个组合命令
   # 2>&1：将标准错误重定向到标准输出的位置。由于标准输出已经被重定向到 all_output.txt 文件，所以标准错误也会被重定向到同一个文件。
   # &1：表示将标准错误重定向到与标准输出相同的位置。 可以理解为引用标准输出的位置 在这个例子中也就是all_output.txt
   # 如果你只是使用 ls > all_output.txt，那么只有标准输出会被重定向到 all_output.txt，而标准错误仍然会显示在终端上。通过添加 2>&1，你确保标准错误也被重定向到同一个文件中，这样所有输出（包括错误消息）都记录在 all_output.txt 中。
   ```

5. **将命令的输出作为输入传递给另一个命令**：

   ```shell
   # 这会将 `ls` 命令的输出通过管道传递给 `grep` 命令，`grep` 会搜索包含 `pattern` 的行。
   ls | grep "pattern"
   ```

#### 1.8.2.3 示例应用

假设你想将一个程序的标准输出和标准错误都重定向到一个文件，你可以这样做：

```shell
./myprogram > output.txt 2>&1
```

或者更简单地使用 `&>`：

```shell
./myprogram &> output.txt
```

这样，程序的所有输出（包括错误消息）都会被记录到 `output.txt` 文件中。



### 1.8.3 标准输入的重定向

标准输入重定向允许你从文件或其他命令获取输入，而不是从键盘。常见的重定向操作符有：

- `<`：将标准输入重定向到一个文件。
- `<<`：将标准输入重定向到一个内联文档（heredoc）。
- `<<<`：将标准输入重定向到一个字符串（这里文档）。

#### 1.8.3.1 常见用法示例

1. **将文件作为标准输入**：

   ```shell
   command < inputfile
   ```

   例如，使用 `cat` 命令读取 `file.txt` 的内容：

   ```shell
   # 这与 `cat file.txt` 的效果相同，都是将 `file.txt` 的内容显示在终端上。
   cat < file.txt
   ```

2. **使用管道将一个命令的输出作为另一个命令的输入**：

   ```
   command1 | command2
   ```

   例如，将 `ls` 命令的输出传递给 `grep` 命令：

   ```shell
   # 这会在当前目录中搜索包含 `pattern` 的文件或目录。
   ls | grep "pattern"
   ```

   

3. **使用内联文档（heredoc）**：

   ```shell
   command << delimiter
   text
   delimiter
   ```

   例如，使用 `cat` 命令创建一个包含多行文本的文件：

   ```shell
   cat <<EOF > myfile.txt
   This is a line of text.
   This is another line of text.
   EOF
   ```

   这会将多行文本写入 `myfile.txt` 文件中，直到遇到 `EOF` 作为结束标志。

4. **使用字符串作为输入（here string）**：

   ```shell
   command <<< "string"
   ```

   例如，将字符串传递给 `wc` 命令以计算单词数量：

   ```shell
   wc -w <<< "Hello, world!"
   ```

   这会输出 `2`，表示字符串 "Hello, world!" 有两个单词。

#### 1.8.3.2  实际应用

假设你有一个需要从文件读取输入的命令，可以这样使用标准输入重定向：

1. **从文件读取输入**：

   ```shell
   sort < unsorted.txt
   ```

   这会将 `unsorted.txt` 文件的内容作为输入传递给 `sort` 命令，并输出排序后的结果。

2. **通过管道传递输入**：

   ```shell
   ps aux | grep "firefox"
   ```

   这会列出所有运行的进程，然后过滤出包含 "firefox" 的进程信息。

3. **内联文档创建文件**：

   ```shell
   cat <<EOF > example.txt
   Line 1
   Line 2
   Line 3
   EOF
   ```

   这会将多行文本写入 `example.txt` 文件中。

#### 1.8.3.3 总结

标准输入是命令读取数据的主要来源，默认是从键盘接收输入。通过重定向操作符 `<`、`<<` 和 `<<<`，可以将文件、字符串或其他命令的输出作为输入传递给命令，使得命令行操作更加灵活和强大。

## 1.9 多命令执行顺序

* 声明多个命令直接该怎么执行

| 多命令执行符 | 格式             | 作用                                                   | 案例              |
| ------------ | ---------------- | ------------------------------------------------------ | ----------------- |
| ;            | 命令1;命令2      | 多个命令执行，命令直接没有任何逻辑关系                 | echo 1;echo2      |
| &&           | 命令1 && 命令2   | 逻辑与，只有命令1执行正确才会执行命令2                 | echo 1 && echo2   |
| \|\|         | 命令1 \|\| 命令2 | 逻辑或，命令1执行失败会执行命令2，反之则 不会执行命令2 | echo 1 \|\| echo2 |

**举例**

```shell
# 使用;符号，即使前面的命令报错了也会执行后面的命令，因为命令之间没有任何关系
ls kk; echo 2

#  逻辑与操作 和js差不多
echo 1 && echo 2

#  逻辑或操作 和js差不多
echo 1 || echo 2
```

## 1.10 管道符号

* 符号为：`|` 
* `｜前`的命令的`执行结果`会作为`｜之后`命令的`输入`

**案例**

```shell
# 假设1.txt有两行 第一行是123 第二行是456
# cat 1.txt的结果会作为 tail -1的输入
# 结果就是显示456
cat 1.txt | tail -1
```

## 1.11 通配符

| 通配符 | 作用                                                 |
| ------ | ---------------------------------------------------- |
| ?      | 匹配一个任意字符                                     |
| *      | 匹配0个或多可任意字符                                |
| []     | 匹配中括号中的任意一个                               |
| [-]    | 匹配中括号中的范围任意一个 eg:[0-9]匹配0-9中任意一个 |
| [^]    | 匹配不是中括号中的任意字符                           |

## 1.12 其他符号

| 符号  | 作用                                                         |
| ----- | ------------------------------------------------------------ |
| ''    | 单引号，在单引号中所有特殊符号，如`$`和`` `都没有特殊含义    |
| ""    | 双引号，在双引号中所有特殊符号都没有特殊含义，但是$  `  \这3个例外，拥有调用变量的值，引用命令和转义的含义 |
| \` \` | 反引号，括起来的是系统命令                                   |
| $()   | 和反引号一样                                                 |
| #     | 在shell脚本中，#开头的行代表注释                             |
| $     | 用于调用变量的值                                             |
| \     | 转义符号                                                     |

**举例**

```shell
# 输出结果就是$PATH
echo '$PATH'

# 输出结果 PATH这个变量的值 也就是当前系统环境变量有哪些
echo "$PATH"

# 输出 ls这个系统命令的执行结果
echo `ls`

```

# 2 变量

## 2.1 变量命名规则

* 必须以字母或下划线开头，名字中间只能由字母，数字和下划线组成
* 变量名的长度不得超过255个字符
* 变量名在有效范围内必须唯一
* 变量`默认类型都是字符串`

## 2.2 变量的类型

* 字符串
* 整型
* 浮点型
* 日期型

## 2.3 用户自定义变量

* 变量名不能以数字开头
* 等号左右两边不能有空格

### **定义变量**

```shell
# 注意 虽然age的值是10 但是他的类型依然是字符串类型
name="zs"
age=10
```

### **输出变量**

* 使用`$`调用变量

```shell
echo $name
echo $age
```

### **值默认都是字符串**

```shell
x=1
y=2
z=$x+$y

# 输出的结果是 1+2 所以可以证明值默认是字符串类型
echo $z

```

### 在赋值的时候引用变量

```shell
# 可以在双引号中之间调用变量
# 也可以使用 ${x} 调用变量 
x=123
y="$x"4
z=0${x}
```

### set

* 查询系统中默认所有已生效的变量，包括系统变量、环境变量，也包括自定义的变量

```shell
set

# 只查询有name的变量
set | grep name
```

### unset

* 删除变量
* unset 变量名

```shell
# 删除name这个变量
unset name
```

## 2.4 环境变量

* 环境变量是`全局变量`，自定义变量是`局部变量`
* `自定义变量`会在`当前shell中生效`，而环`境变量`会在`当前shell以及其子shell中生效`
  * 在shell中输入`bash`命令即可进入一个子shell
* 这种变量主要保存的是和系统操作环境相关的数据
* 环境变量可以自定义，但是`对系统生效的环境变量名`和`变量作用是固定的`

### 自定义环境变量

* 使用export关键字 `export 变量名=变量值`
* 这种方式只能临时创建系统变量，当shell关闭或者新打开一个shell就会没了
* 想要永久生效，需要修改文件

```shell
export name=zs
```

### env

* 仅仅用来查看环境变量，而看不到本地变量

```shell
# 查看所有的环境变量
env

# 查看环境变量中name相关的环境变量
env | grep name
```

### 常见的环境变量

| 变量名     | 含义                                                         |
| ---------- | ------------------------------------------------------------ |
| HOSTNAME   | 主机名                                                       |
| SHELL      | 当前的shell,LINUX中的终端有很多种,这个命令就是查看当前用的哪一种终端 |
| HISTSIZE   | 历史命令条数                                                 |
| SSH_CLIENT | 当前操作环境如果是用ssh连接的话，这里会记录客户端的IP        |
| USER       | 当前登录的用户                                               |

```shell
echo $HOSTNAME
echo $SHELL
echo $HISTSIZE
echo $SSH_CLIENT
echo $USER
```

### PATH

* `系统搜索的路径`
* 具体看上面`命令生效顺序章节`

```shell
 echo $PATH
 /root/.nvm/versions/node/v16.15.1/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin
```

**如何可以让一个自定义的脚本可以直接执行**

```shell
# 现在有hello.sh这个脚本 想让他在全局任意位置可以执行
# 也就是直接输入hello.sh可直接执行

# 方式一
# 把这个文件拷贝到 $PATH的其中任意目录下
# 比如/root/bin
# 原理：这个命令执行的顺序是从$PATH这一堆路径中查找的，找到了就执行


# 方式二 
# 把脚本文件所在的目录添加到PATH变量中
# 假如这个脚本文件在 /root/shells下面
# 注意linux中路径直接到分隔符用 :
export PATH="$PATH":/root/shells
```

### 语系环境变量

* 查询当前系统语系
* 在Linux中通过`locale命令`来设置程序运行的不同语言环境
* locale由ANSI C提供支持
* `LANG：定义系统主语系的变量`

```shell
# locale的命令规则为<语言>_<地区>.<字符集编码>
# 如 zh_CN.UTF-8
# zh表示中文。CN表示大陆地区 UTF-8表示字符集

# 查询当前系统语系
locale

# 查询当前系统主语系
echo $LANG
```

### 中文支持

* 图像界面可以支持中文
* 第三方工具比如xshell语系设置正确可以支持中文
* 虚拟机中纯字符界面不支持中文

## 2.5 参数位置变量

* 这种变量主要是用来获取脚本执行时传入的参数或者数据的
* 变量名不能自定义，变量的作用也是固定的

| 变量名 | 作用                                                         |
| ------ | ------------------------------------------------------------ |
| $n     | n是数字，$0表示命令本身，$1-9表示第1到第9个参数，10以上的参数需要用大括号包含,如${10} |
| $*     | 获取命令中所有参数，但是把所有参数当作一个整体               |
| $@     | 获取命令中所有参数，但是把所有参数进行区分，类似js的arguments |
| $#     | 获取所有参数的个数                                           |

**举例**

sum.sh

```shell
#!/bin/bash
# 获取传入的第一个参数和第二个参数的和
x=$1
y=$2
sum=$(($1+$2))
echo $sum

# 执行该文件 输出结果为7
sh sum.sh 3 4
```

```shell
# $* 
# 比如输入如下
sh for.sh 1 2 3
# $*  会将1 2 3看作是一个整体
# 那么进行循环的时候也只会执行一次

# $@ 会将1 2 3拆分
# 如果进行循环 那么就会执行三次



```

## 2.6 预定义变量

* 脚本中已经定义好的变量，变量名不能自定义，作用也是固定的

| 变量名 | 作用                                                         |
| ------ | ------------------------------------------------------------ |
| $?     | 最后一次执行的命令的返回状态，0表示正确执行，非0表示不正确执行 |
| $$     | 当前进行的进程号(PID)                                        |

```shell
# $?
# 假如我执行 ls 命令
# 然后 输入 echo $? 可以查看ls的执行结果
echo $?

```

## 2.7 read

* 和用户交互用的命令

**语法**

```shell
read [选项] [变量名]
```

**选项**

* `-p` 提示信息，在等待read输入时，输出提示信息
* `-t`  秒数：read命令会已知等待用户输入，使用此选项可以指定等待时间
* `-n`  字符数，read命令只接受指定的字符数就会执行
* `-s`  隐藏输入的数据，适用于机密信息的输入

**举例**

read.sh

```shell
#!/bin/bash

# 注意每个交互输入完毕之后 按回车进行下一步
# -t 3 如果3秒之后还没有输入 就会跳过当前交互 执行下一个交互 那么对应的name这个变量的值也是空的
# -p '信息' 表示给用户信息提示
read -p 请输入姓名 -t 3 name
echo -e '\n'
# -n 1 指定用户输入的字数只有1个 当输入一个之后不用按回车 会自动的执行下一个交互
read -p 请输入性别[男/女] -n 1 sex
echo -e '\n'
# -s 输入的时候不显示出来
read -p  请输入密码 -s  passwd
echo -e '\n'
echo $name $sex $passwd

# 在shell 中输入 sh read.sh即可执行
```

# 3 运算符

* shell语言是弱类型的语言
* 且默认声明的变量是字符串类型

## 3.1 declare

* 用于声明变量的类型

| 选项 | 含义                 |
| ---- | -------------------- |
| -    | 给变量设定类型属性   |
| +    | 取消变量的类型属性   |
| -a   | 将变量声明为属组类型 |
| -i   | 将变量声明为整数类型 |
| -x   | 将变量声明为环境变量 |
| -r   | 将变量声明为只读变量 |
| -p   | 显示变量被声明的类型 |

**举例**

```shell
# - 和 +  后面都可以跟a、i、x、r

# 可以使用declare声明带类型的变量
# 也可以给已声明的类型增加或者取消变量类型属性
# 一旦设置变量为只读类型将无法使用+r取消只读类型

# 案例一
# 声明变量a、b 声明变量c是a+b的值
# 默认情况下c的值是1+2 因为变量默认情况下是字符串类型的
 a=1
 b=2
 c=$a+$b
 echo $c  # 1+2
# 只需要这样声明就行
# 表示声明一个变量c类型是整型
declare -i c=$a+$b
echo $c # 3

# 案例2 取消变量x的整型类型
#声明一个变量x 类型是整型
declare -i x=1
# 显示x的类型
declare -p x # declare -i x="1"

#取消x的整型类型
declare +i x
# 显示x的类型
declare -p x # declare -- x="1"
```

**数组**

```shell
# 声明为数组类型
declare -a names

# 给数组赋值
names[0]=zhangsan
names[1]=lisi

# 默认只打印第一个元素
# 直接输出names 只打印第一个元素 
# echo $names 相当于 echo ${names[0]}
echo $names # zhangsan

# 打印第二个元素 
echo ${names[1]}  # lisi

# 打印全部元素
echo ${names[*]} # zhangsan lisi

# 什么时候使用 ${} 调用变量

# 当输出的变量作为一个整体的时候使用`${变量}`输出
# 比如想要打印names的第一个元素
# 使用$names[0]
# 这是错误的因为会把$names当作一个整体然后打印zhangsan[0] zhangsan不是一个变量所以结果就是zhangsan[0]
echo $names[0] # zhangsan[0]

# 正确做法是
echo ${names[0]} # zhangsan 


```



**声明环境变量**

* `export`命令声明的环境变量 最终执行的是`declare -x`命令

```shell
# 案例 设置kk为环境变量
declare -x kk=3

# 查询一下是否设置成功
env | grep kk  # kk=1
```

## 3.2 数值运算的方法

* 方法比较多 看案例

```shell
num1=1
num2=2

# 方式一
# 注意+两边必须要有空格
sum=$(expr $num1 + $num2)
echo $sum #3

# 方式二
# $(())作用看下面的笔记
sum1=$(($num1+$num2))
echo $sum1 #3

# 方式三
sum2=$[$num1+$num2]
echo $sum2 #3

# 方式四
declare -i sum3=$num1+$num2
echo $sum3 #3
```

## 3.3 优先级

* 优先级越高越先执行

  | 优先级 | 运算符                                       | 说明                               |
  | ------ | -------------------------------------------- | ---------------------------------- |
  | 13     | -，+                                         | 单目负、单目正                     |
  | 12     | !，~                                         | 逻辑非、按位取反或补码             |
  | 11     | *，/，%                                      | 乘、除、取模                       |
  | 10     | +，-                                         | 加、减                             |
  | 9      | <<，>>                                       | 按位左移、按位右移                 |
  | 8      | <，<=，>，>=                                 | 小于或等于、大于或等于、小于、大于 |
  | 7      | ==，!=                                       | 等于、不等于                       |
  | 6      | &                                            | 按位与                             |
  | 5      | ^                                            | 按位异或                           |
  | 4      | \|                                           | 按位或                             |
  | 3      | &&                                           | 逻辑与                             |
  | 2      | \|\|                                         | 逻辑或                             |
  | 1      | =，+=，-=，*=，/=，%=，&=，^=，\|=，<<=，>>= | 赋值、运算且赋值                   |

## 3.4 (())和$(())

在 Bash 中，`(( ))` 和 `$(())` 都用于执行算术运算，但它们的行为和用途略有不同。

### `(( ))` 的行为

- **主要用途**：用于执行算术运算和条件判断。
- **返回结果**：`(( ))` 本身不返回值，而是设置退出状态码（exit status）。如果表达式的结果为非零，则退出状态码为 0（表示真）；如果结果为零，则退出状态码为 1（表示假）。

#### 示例

```sh
#!/bin/bash

num1=5
num2=10

# 使用 (( )) 进行加法运算
((sum = num1 + num2))
echo "Sum: $sum"

# 使用 (( )) 进行条件判断
if ((num1 < num2)); then
    echo "num1 小于 num2"
else
    echo "num1 不小于 num2"
fi
```

在这个例子中，`((sum = num1 + num2))` 计算并设置 `sum` 的值，但 `(( ))` 本身不返回值。相反，它设置了退出状态码，这在条件判断中非常有用。

### `$(())` 的行为

- **主要用途**：用于命令替换，将算术运算的结果作为字符串返回。
- **返回结果**：`$(())` 返回算术运算的结果，并将其作为字符串插入到命令中。

#### 示例

```sh
#!/bin/bash

num1=5
num2=10

# 使用 $(()) 进行加法运算
sum=$(($num1 + $num2))
echo "Sum: $sum"
```

在这个例子中，`$(($num1 + $num2))` 计算并返回结果 `15`，然后将其赋值给变量 `sum`。

### 总结

- **`(( ))`**：
  - 用于执行算术运算和条件判断。
  - 不返回值，而是设置退出状态码。
  - 结果可以直接用于控制结构中。

- **`$(())`**：
  - 用于命令替换。
  - 返回算术运算的结果作为字符串。
  - 适合嵌入到其他命令中。

### 示例对比

#### 使用 `(( ))`

```sh
#!/bin/bash

num1=5
num2=10

# 使用 (( )) 进行加法运算
((sum = num1 + num2))
echo "Sum: $sum"

# 使用 (( )) 进行条件判断
if ((num1 < num2)); then
    echo "num1 小于 num2"
else
    echo "num1 不小于 num2"
fi
```

#### 使用 `$(())`

```sh
#!/bin/bash

num1=5
num2=10

# 使用 $(()) 进行加法运算
sum=$(($num1 + $num2))
echo "Sum: $sum"
```

### 结论

- `(( ))` 更适合用于控制结构和条件判断，因为它设置退出状态码。
- `$(())` 更适合用于命令替换和将结果嵌入到其他命令中，因为它返回字符串结果。

# 4 环境变量配置文件

## 4.1 source

* 修改完配置文件后，必须注销重新登录，配置文件才能生效
* 使用source命令，`可以直接让修改过的配置文件生效`

**案例**

```shell
# 假如修改了 bash_profile配置文件
# 在不注销的情况下使配置文件生效

# 方式一 使用source命令
source bash_profile

# 方式二 使用 . 直接执行当前文件
. bash_profile
```

## 4.2 环境变量配置文件简介

* 环境变量配置文件中，主要是`定义系统操作环境生效的系统默认环境变量`
* PATH、HISTSIZE、PS1、HOSTNAME等环境变量写入对应的环境配置文件

| 路径            | 说明               |
| --------------- | ------------------ |
| /etc/profile    | 针对所有的用户生效 |
| /etc/bashrc     | 针对所有的用户生效 |
| ~/.bash_profile | 只会对当前用户生效 |
| ~/.bashrc       | 只会对当前用户生效 |

## 4.3 环境变量配置文件的功能

### **/etc/profile**

* 在这里修改`系统变量`
* 这个文件`针对所有的shell生效的`

| 变量名   | 含义     |
| -------- | -------- |
| USER     | 用户名   |
| LOGNAME  | 登录名   |
| MAIL     | 邮箱地址 |
| PATH     | 查找路径 |
| HOSTNAME | 主机名   |
| umask    | 权限掩码 |

### **~/.bash_profile**

* 在这里修改`PATH`路径
* 这个文件只`针对当前用户的shell生效`

### **/etc/bashrc**

* shell有很多的类型，比如bashsehll、zhshell等等
* 这个文件`针对的是所有的bash shell生效的`

### **~/.bashrc**

* 这个文件针对的是`当前用户的bash shell生效的`
* 这里修改别名，配置alias



###  其他配置文件

**～/.bash_logout**

* 注销时生效的环境变量配置文件
* 当注销时，会执行这个配置文件



**~/.bash_history**

* 当正确退出计算机时候，会把历史记录写入改文件



**Shell登录信息**

* 当登录的时候会执行的配置文件
* 本地终端欢迎信息`/etc/issue`
* 远程终端欢迎信息`/etc/issue.net`
* 本地和远程都生效`/etc/motd`

| 参数 | 含义                       |
| ---- | -------------------------- |
| /d   | 当前系统日期               |
| /s   | 显示操作系统名称           |
| /l   | 显示登录的终端号           |
| /m   | 显示硬件体系结构           |
| /n   | 显示主机名                 |
| /o   | 显示域名                   |
| /r   | 显示内核版本               |
| /t   | 显示当前系统时间           |
| /u   | 显示当前登录的用户名序列号 |



# 5 文件操作

## 5.1 cut

* cut用来提取文本中的某一部分文本
* 语法 `cut [选项] 文件名或内容`
* 选项
  * `-f `列号，用来指定分隔第几列的数据
  * `-d` 分隔符，被分割的文本以什么符号为规律进行分隔

**举例**

```shell
# demo.txt的内容如下
i-1-2-r-c
w-1-2-r-c
q-1-2-r-c

# 现在需要提取的是第一列和最后一列的数据
# 可以看到都是以-进行分隔的，所以-d就写-
# 这样-f才能正确的采集到列号
cut -f 1,5 -d -

# 输出结果
i-c
w-c
q-c

```

## 5.2 printf

* 用于格式化并输出文本

* 语法：`printf 输出格式 填充内容`

* rintf 不会像 **echo** 自动添加换行符，我们可以手动添加 **\n**。

* 只列举部分使用 用到的时候可以去查[链接](https://www.runoob.com/linux/linux-shell-printf.html#:~:text=printf%20%E5%91%BD%E4%BB%A4%E6%A8%A1%E4%BB%BF%20C%20%E7%A8%8B%E5%BA%8F%E5%BA%93%EF%BC%88library%EF%BC%89%E9%87%8C%E7%9A%84%20printf%20%28%29%20%E7%A8%8B%E5%BA%8F%E3%80%82%20printf,printf%20%E7%9A%84%E8%84%9A%E6%9C%AC%E6%AF%94%E4%BD%BF%E7%94%A8%20echo%20%E7%A7%BB%E6%A4%8D%E6%80%A7%E5%A5%BD%E3%80%82%20printf%20%E4%BD%BF%E7%94%A8%E5%BC%95%E7%94%A8%E6%96%87%E6%9C%AC%E6%88%96%E7%A9%BA%E6%A0%BC%E5%88%86%E9%9A%94%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%8C%E5%A4%96%E9%9D%A2%E5%8F%AF%E4%BB%A5%E5%9C%A8%20printf%20%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E8%BF%98%E5%8F%AF%E4%BB%A5%E5%88%B6%E5%AE%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%AE%BD%E5%BA%A6%E3%80%81%E5%B7%A6%E5%8F%B3%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F%E7%AD%89%E3%80%82)

  

**参数说明**

| 参数       | 含义                            |
| ---------- | ------------------------------- |
| %ns        | 输出字符串，n表示输出几个字符串 |
| %nd 或 %ni | 输出整数，n表示输出多少个整数   |
|            |                                 |

**举例**

```shell
# 
printf "%-10s %-8s %-4s\n" 姓名 性别 体重kg

# 输出结果
# -10s 指一个宽度为 10 个字符（- 表示左对齐，没有则表示右对齐），任何字符都会被显示在 10 个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。
# 对应的填充内容是姓名 所以算上姓名这两字还会输出8个空格 加起来一共10个字
# -8s 输出一个宽为8的字符 算上性别填充两个字符还要输出6个空格
# -4s 输出一个宽为4的字符 体重kg正好是4个字符
# \n 换行符。输出这些后会换行继续输出
姓名        性别      体重kg


# 假设有一个a.txt 内容如下 格式是没有规律的
# 所以就无法用cut命令来切割想要的内容了
# 可以使用printf先格式化 然后在切割
姓名   性别 体重kg 
 郭靖 男   66.1234
杨过 男   48.6543
郭芙  女 47.9876 

# $(cat a.txt) 可以拿到执行后的内容
# %s- 表示填充内容后面是-隔开
printf "%s-%s-%s\n" $(cat a.txt)
# 输出结果 这样就规律了 
姓名-性别-体重kg
郭靖-男-66.1234
杨过-男-48.6543
郭芙-女-47.9876

#使用cut配合使用
printf "%s-%s-%s\n" $(cat a.txt) | cut -d - -f 1,2
# 执行结果
姓名-性别
郭靖-男
杨过-男
郭芙-女
```

## 5.3 awk

**语法**

```shell
awk 条件1{动作1} 条件2{动作2}...条件n{动作n} 文件名
```

- 条件(Pattern)

  - 一般使用表达式作为条件
  - eg
  - x > 10 判断 x 的值是否大于 10

- 常见动作(Action)
  - 格式化输出
  - print：打印输出。
  - 变量赋值：如 `sum += $1`。
  - 控制语句：如 `if、for、while` 等
  
  

**内置变量**

awk 提供了一些内置变量，常用的有：

- $0：当前记录（整行文本）。
- $1,2, ..., $n：当前记录的第 n 个字段。
- NR：当前记录数（行号）。
- NF：当前记录的字段数。
- FS：字段分隔符（默认是空格或制表符）。
- OFS：输出字段分隔符（默认是空格）。
- RS：记录分隔符（默认是换行符）。
- ORS：输出记录分隔符（默认是换行符）。

#### **NR**

在 `awk` 中，`NR` 是一个内置变量，表示当前处理的记录（行）号。`NR` 从 1 开始，每处理一行数据，`NR` 的值就会增加 1。因此，`NR` 可以用来跟踪当前处理的是文件中的第几行。



**使用 `NR` 的示例**

**打印行号和行内容**

假设有一个名为 `data.txt` 的文件，内容如下：

```
Alice 30 50000
Bob 25 60000
Charlie 35 70000
```

你希望打印每一行的行号和行内容。

```sh
awk '{ print NR, $0 }' data.txt
```

输出：

```
1 Alice 30 50000
2 Bob 25 60000
3 Charlie 35 70000
```

在这个例子中，`print NR, $0` 打印当前行号和整行内容。



**处理特定行**

你可以使用 `NR` 来处理特定的行。例如，只处理文件中的前两行。

```sh
awk 'NR <= 2 { print $0 }' data.txt
```

输出：

```
Alice 30 50000
Bob 25 60000
```

在这个例子中，`NR <= 2` 作为条件，只处理行号小于等于 2 的行。



**结合 `BEGIN` 和 `END` 块**

你可以结合 `BEGIN` 和 `END` 块来使用 `NR`。例如，统计文件中的总行数。

```sh
awk 'END { print "Total number of lines:", NR }' data.txt
```

输出：

```
Total number of lines: 3
```

在这个例子中，`END` 块在处理完所有输入数据之后执行，`NR` 的值表示总行数。

**BEGIN**

在 `awk` 中，`BEGIN` 是一个特殊的模式块，用于在处理任何输入数据之前执行一次初始化操作。你可以在 `BEGIN` 块中设置变量、打印标题或进行其他初始化工作。



#### BEGIN 块的使用

`BEGIN` 块的语法如下：

```sh
awk 'BEGIN { ... } { ... }' filename
```

在 `BEGIN` 块中，你可以执行任何合法的 `awk` 语句。常见的用途包括设置字段分隔符（`FS` 和 `OFS`）、初始化变量、打印表头等。

**示例**



**设置字段分隔符**

假设有一个名为 `data.txt` 的文件，内容如下：

```
name:age:salary
Alice:30:50000
Bob:25:60000
Charlie:35:70000
```

你希望使用冒号（`:`）作为输入字段分隔符，并使用逗号（`,`）作为输出字段分隔符。

```sh
awk 'BEGIN { FS = ":"; OFS = "," } { print $1, $2, $3 }' data.txt
```

输出：

```
name,age,salary
Alice,30,50000
Bob,25,60000
Charlie,35,70000
```



**打印表头**

假设你有一个文件 `data.txt`，内容如下：

```
Alice 30 50000
Bob 25 60000
Charlie 35 70000
```

你希望在输出中添加一个表头。

```sh
awk 'BEGIN { print "Name,Age,Salary" } { print $1 "," $2 "," $3 }' data.txt
```

输出：

```
Name,Age,Salary
Alice,30,50000
Bob,25,60000
Charlie,35,70000
```



**初始化变量**

你可以在 `BEGIN` 块中初始化变量，然后在处理数据时使用这些变量。

```sh
awk 'BEGIN { total_salary = 0 } { total_salary += $3 } END { print "Total Salary:", total_salary }' data.txt
```

输出：

```
Total Salary: 180000
```

在这个例子中，`BEGIN { total_salary = 0 }` 初始化了一个变量 `total_salary`，然后在处理每一行数据时累加第三个字段的值。最后，在 `END` 块中打印总工资。

**END**

在 `awk` 中，`END` 是另一个特殊的模式块，用于在处理完所有输入数据之后执行一次收尾操作。你可以在 `END` 块中进行总结性工作，例如打印累计结果、释放资源或进行其他清理工作。



#### `END` 块的使用

`END` 块的语法如下：

```sh
awk '{ ... } END { ... }' filename
```

在 `END` 块中，你可以执行任何合法的 `awk` 语句。常见的用途包括打印累计结果、计算平均值、输出统计信息等。

**示例**



**打印累计结果**

假设有一个名为 `data.txt` 的文件，内容如下：

```
Alice 30 50000
Bob 25 60000
Charlie 35 70000
```

你希望计算并打印所有人的总工资。

```sh
awk '{ total_salary += $3 } END { print "Total Salary:", total_salary }' data.txt
```

输出：

```
Total Salary: 180000
```

在这个例子中，`total_salary += $3` 在处理每一行数据时累加第三个字段的值。最后，在 `END` 块中打印总工资。

**计算平均值**

假设你希望计算并打印所有人的平均工资。

```sh
awk '{ total_salary += $3; count++ } END { print "Average Salary:", total_salary / count }' data.txt
```

输出：

```
Average Salary: 60000
```

在这个例子中，`total_salary += $3` 累加第三个字段的值，`count++` 计数行数。最后，在 `END` 块中计算并打印平均工资。



**结合 `BEGIN` 和 `END`**

你可以同时使用 `BEGIN`、主处理块和 `END` 块来完成复杂的任务。

```sh
awk 'BEGIN { print "Processing data..." }
     { total_salary += $3; count++ }
     END { print "Total Salary:", total_salary; print "Average Salary:", total_salary / count }' data.txt
```

输出：

```
Processing data...
Total Salary: 180000
Average Salary: 60000
```

在这个例子中，`BEGIN` 块打印开始处理的消息，主处理块累加工资和计数行数，`END` 块打印总工资和平均工资。



#### **FS**

`FS` 是 `awk` 中的一个内置变量，用于指定输入字段分隔符（Field Separator）。`awk` 使用 `FS` 来确定如何分割输入行中的字段。默认情况下，`FS` 是空格或制表符，但你可以根据需要将其设置为其他字符或字符串。

**使用 `FS`**

你可以通过以下几种方式设置 `FS`：

1. **在命令行中使用 `-F` 选项**：

   ```sh
   awk -F: '{print $1, $2}' filename
   ```

2. **在 `BEGIN` 块中设置 `FS`**：
   ```sh
   awk 'BEGIN { FS = ":" } { print $1, $2 }' filename
   ```

**示例**

假设有一个名为 `data.txt` 的文件，内容如下：

```
name:age:salary
Alice:30:50000
Bob:25:60000
Charlie:35:70000
```

你希望使用冒号（`:`）作为字段分隔符。

**使用 `-F` 选项**

```sh
awk -F: '{print $1, $2}' data.txt
```

输出：

```
name age
Alice 30
Bob 25
Charlie 35
```

**在 `BEGIN` 块中设置 `FS`**

```sh
awk 'BEGIN { FS = ":" } { print $1, $2 }' data.txt
```

输出与上面相同：

```
name age
Alice 30
Bob 25
Charlie 35
```

**复杂示例**

假设你有一个文件 `data.csv`，内容如下：

```
name,age,salary
Alice,30,50000
Bob,25,60000
Charlie,35,70000
```

你希望使用逗号（`,`）作为字段分隔符，并打印每行的第一个和第三个字段。

**使用 `-F` 选项**

```sh
awk -F, '{print $1, $3}' data.csv
```

输出：

```
name salary
Alice 50000
Bob 60000
Charlie 70000
```

**在 `BEGIN` 块中设置 `FS`**

```sh
awk 'BEGIN { FS = "," } { print $1, $3 }' data.csv
```

输出与上面相同：

```
name salary
Alice 50000
Bob 60000
Charlie 70000
```

#### OFS

`OFS` 是 `awk` 中的一个内置变量，用于指定输出字段分隔符（Output Field Separator）。默认情况下，`awk` 使用空格作为输出字段分隔符。如果你希望使用其他字符或字符串作为输出字段分隔符，可以通过设置 `OFS` 变量来实现。

**使用 `OFS`**

你可以在 `awk` 程序中通过 `BEGIN` 块来设置 `OFS` 变量。例如：

```sh
awk 'BEGIN { OFS = "," } { print $1, $2, $3 }' filename
```

**示例**

假设有一个名为 `data.txt` 的文件，内容如下：

```
name age salary
Alice 30 50000
Bob 25 60000
Charlie 35 70000
```

你希望将输出字段分隔符设置为逗号（`,`）。

**使用 `OFS` 设置输出字段分隔符**

```sh
awk 'BEGIN { OFS = "," } { print $1, $2, $3 }' data.txt
```

输出：

```
name,age,salary
Alice,30,50000
Bob,25,60000
Charlie,35,70000
```

在这个例子中，`BEGIN { OFS = "," }` 确保了 `awk` 在处理任何输入数据之前，将输出字段分隔符设置为逗号（`,`）。这样，`awk` 能够正确地将每一行的字段用逗号分隔开来。



**结合 `FS` 和 `OFS`**

你可以同时设置输入字段分隔符 `FS` 和输出字段分隔符 `OFS`。例如，假设输入文件使用冒号（`:`）作为字段分隔符，而你希望输出使用逗号（`,`）作为字段分隔符：

假设有一个名为 `data.txt` 的文件，内容如下：

```
name:age:salary
Alice:30:50000
Bob:25:60000
Charlie:35:70000
awk 'BEGIN { FS = ":"; OFS = "," } { print $1, $2, $3 }' data.txt
```

输出：

```
name,age,salary
Alice,30,50000
Bob,25,60000
Charlie,35,70000
```

在这个例子中，`BEGIN { FS = ":"; OFS = "," }` 确保了 `awk` 在处理任何输入数据之前，将输入字段分隔符设置为冒号（`:`），并将输出字段分隔符设置为逗号（`,`）。



## 5.4 sed 命令

- sed 是一个轻量级的编辑器，主要用来对数据进行选取、替换、和新增操作
- **语法**
  - sed [选项] '[动作]' 文件名
- 所有的动作必须使用单引号包裹
- 默认情况下sed是`不会修改原文件的`，只会将结果输出到屏幕上



**动作**

* 带n的表示制定行数，如果不指定默认每行都会操作 ,n,m一起写表示范围eg;
* 如果想要插入多行可以使用`\n`，进行换行 eg:`sed '1a ee\nrr' 3.txt`

| 参数   | 含义                                                         |
| ------ | ------------------------------------------------------------ |
| [n,m]a | 追加，在每一行或者指定行下面添加一行或多行                   |
| [n,m]c | 行替换，用c后面的字符串替换原始行                            |
| [n,m]s | 字符串替换，用一个字符串替换另一个字符串 语法`sed 's/pattern/replacement/' inputfile` pattern指的是正则，斜杠 `/` 通常用于分隔模式和替换字符串 ，分隔符也可以使用其他的比如`# :`等只要不与模式或动作冲突即可 |
| [n,m]i | 插入，在指定行掺入一行或多行                                 |
| [n,m]d | 删除指定行,不指定删除全部行                                  |
| [n,m]p | 打印，输出指定行                                             |

**选项**

| 参数 | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| -n   | 一般sed命令会把所有的数据都输出到屏幕上，如果加入此选项只会把处理过的行输出到屏幕上 |
| -e   | 允许对输入数据应用多条sed编辑命令                            |
| -i   | 用sed的修改直接修改源文件，而不是在屏幕上输出                |

**举例**

```shell
#1.txt内容如下
11
22
33

# [n]a 追加
#  注意如果你的文件是一个空的 就是连行都没有 那么输出也是没有东西的下面的命令同理

# 在第一行后面追加 ee
sed '1a ee' 3.txt 
# 输出
11
ee
22
33

# 在第一行和第二行追加ee
sed  '1,2a ee' 3.txt 
# 输出
11
ee
22
ee
33

# 在第一行后面追加两行ee和rr
sed '1a ee\nrr' 3.txt 
# 输出
11
ee
rr
22
33

# 不指定行数 默认每行后面都会追加
sed '1a ee' 3.txt 
11
ee
22
ee
33
ee

# [n]c 同[n]a一样

# s
# 将1替换成A
# 添加g 否则只替换找到的第一个
# / 表示命令分割
sed 's/1/A/g' 3.txt
# 输出
AA
22
33

# [n]i
# 在第一行插入 ee。那么原本的行都会下移一行
sed '1i ee' 3.txt 
# 输出
ee
11
22
33

# [n]d
# 删除第一行
sed '1d' 3.txt 
# 输出
22
33

#[n]p
# sed 命令中的 p 命令用于打印指定的行。默认情况下，sed 会打印处理后的每一行，但通过使用 p 命令，你可以控制只打印特定的行。
#
sed '2p' 3.txt 
 
# 输出 sed 会在处理每一行时默认打印该行，然后根据 2p 命令再打印一次第 2 行。这会导致第 2 行被打印两次。
11
22
22
33


# -n
sed -n '1a ee' 3.txt 
# 输出 只会把处理过的结果显示
ee

# -e
# 将所有的1替换成A 然后在第3行后追加hhhh
sed -e 's/1/A/g' -e '3a hhhh' 3.txt 

# 输出
AA
22
33
hhhh
```

## 5.5 排序命令sort

* **语法**
  * sort [选项] 文件名或内容
* 字典顺序（lexicographical order）是指按照字母表顺序对字符串进行排序的方式。
* 默认情况下，`sort` 命令就是按照字典顺序对文件内容进行排序的。

**选项**

| 参数     | 含义                                                  |
| -------- | ----------------------------------------------------- |
| -f       | 忽略大小写                                            |
| -n       | 以数值型进行排序，                                    |
| -r       | 反向排序，默认从小到大                                |
| -t       | 指定分隔符，默认分割符是制表符                        |
| -k n[,m] | 指定每行的比较范围，如果不指定m 会从n开始到，直到尾行 |

**举例**

```shell
# sort的比较规则如下
# 如果当前行的第一个字符和下一行的第一个字符相同，sort 命令会比较当前行和下一行的第二个字符 以此类推，直到找到不同的字段为止。如果所有字段都相同，那么行的顺序将保持不变（即稳定排序）。

# sort.txt内容如下
10 100
20 200
30 300
40 400

# 默认排序
# 默认是按照字典顺序排序的
sort sort.txt
# 输出
10 100
20 200
30 300
40 400

# -n 
# 会找到每行出现的第一个数值然后和下一行出现的第一个数值进行比较
# 1.txt内容如下
apple 2
apple 1

sort 1.txt
# 输出
apple 1
apple 2


# -k n[,m]
# 如果不指定m 会从n开始到，直到尾行
# 在默认情况下，sort 命令会从每行的第一个字符开始比较，如果第一个字符相同，则比较第二个字符，依此类推，直到找到不同的字符为止。如果所有字符都相同，则行的顺序保持不变（即稳定排序）。
# 但是我们可以指定按照每行的第几个字段进行排序 

# 1.txt 内容如下
22 34
12 44

# 从第二个字段开始到第二个字段结束的内容进行排序(比较规则看上面)
# 所以就只会比较每行的第二个字段的内容
# 如果 -k 2,3 那么就会比较每行的第二个字段到第三个字段的所有内容
# 就是知道一个比较大范围
sort -k 2,2 1.txt
# 输出
22 34
12 44


# -t 默认是按照制表符进行分割
# 上面提到-k可以指定范围，如果每行的内容使用的是别的符合进行分割就可以使用-t
# 1.txt
22:34
12:34

# 指定分隔符是: 比较范围是第二个字段开始到每行的末尾
sort -t : -k 2 4.txt 
# 输出
22:34
12:44
```

## 5.6 wc

`wc`（word count）命令是 Unix 和 Unix-like 操作系统中的一个命令行工具，用于计算文件中的行数、字数和字节数。它可以处理一个或多个文件，并输出统计信息。

**语法**

```sh
wc [选项] [文件...]
```

**常用选项**

- `-l`：显示行数。
- `-w`：显示字数(单词数)。
  - hello 表示一个单词

- `-c`：显示字节数。
  - 统计在 ASCII 编码中所占的字节数

- `-m`：显示字符数
  - hello 就表示5个字符

- `-L`：显示最长行的长度。

**示例**



```shell
# 假设有一个文件 `example.txt`，内容如下：
Hello world
This is a test file
With multiple lines

#  统计行数、字数和字节数
wc example.txt
# 输出
# 3表示行数 8表示字数(一共有10个单词) 45表示字节数
3  10 45 example.txt

# 只统计行数
wc -l example.txt
# 输出
3 example.txt

# 其他选项同理

```



**处理多个文件**

如果你有多个文件，可以一次性处理它们：

```sh
wc file1.txt file2.txt
```

输出将显示每个文件的统计信息以及总计：

```
  3  8 45 file1.txt
  4 10 50 file2.txt
  7 18 95 total
```

# 6.流程控制

## 6.1 条件判断

### 6.1.1 test命令和[]命令

* test命令用于`评估条件表达式`，并且`返回`一个`退出状态码`。退出状态码为`0表示条件为真`，`非0表示条件为假`。通常`用于条件判断`。

* test`不会`直接输出结果，只会返回一个退出状态码
  * 所以不能echo直接输出
  * 如果想要查看test输出看下面举例
* `退出状态码`
  * `0`表示命令执行成功
  * `非0`表示执行失败，`不同的非0`可以表示不同的错误类型
* `$?`: 是一个特殊的变量，用于获取上一个命令的退出状态码

**语法**

```shell
test 表达式
```

**举例**

```shell
# 判断1.txt文件是否存在
# test -e 1.txt 返回0 所以走存在 因为退出状态码0表示真 不要和js搞混了
test -e 1.txt && echo '存在' || echo '不存在'
# 输出
存在

# 查看test的退出状态码
test -e 1.txt
echo $0
# 输出
0
```

#### [] 命令

* `[]`命令是test的简写，功能和test完全相同

**语法**

```shell
[表达式]
```

**举例**

```shell
# 判断1.txt文件是否存在
# 注意表达式和[]之间要有空格
[ -e 1.txt ] && echo '存在' || echo '不存在'
```



### 6.1.2 按照文件类型进行判断

| 选项 | 含义                               |
| ---- | ---------------------------------- |
| -d   | 文件是否存在并且是目录             |
| -e   | 文件是否存在，不管是文件或者文件夹 |
| -f   | 文件是否存在并且是普通文件         |
| -b   | 文件是否存在并且是块设备文件       |
| -c   | 文件是否存在并且是字符设备文件     |
| -L   | 文件是否存在并且是链接文件         |
| -p   | 文件是否存在并且是管道文件         |
| -s   | 文件是否存在并且是非空文件         |
| -S   | 文件是否存在并且是套接字文件       |

**举例**

```shell
# 判断1.txt文件是否存在
test -e 1.txt && echo '存在' || echo '不存在'
# 输出
存在

# 判断a是否存在且是否是文件夹  a是一个没有后缀的文件
# 因为linux是不按照后缀区分的 后缀只是为了方便阅读 所以当不知道是文件夹还是文件的时候可以进行判断
[ -d a ] && echo 'yes' || echo 'no'
# 输出
no
```

### 6.1.3 按照文件(夹)权限进行判断

| 选项 | 含义                                  |
| ---- | ------------------------------------- |
| -r   | 文件(夹)是否存在,并且是否拥有读的权限 |
| -w   | 文件(夹)是否存在,并且是否拥有读的权限 |
| -x   | 文件(夹)是否存在,并且是否拥有读的权限 |

**举例**

```shell
# 文件夹a是否拥有执行的权限
[ -x a ] && echo 'yes' || echo 'no'
# 输出
yes

# 文件1.txt是否拥有写的权限
[ -w 1.txt ] && echo 'yes' || echo 'no'
# 输出
yes
```

### 6.1.4 两个文件(夹)间的比较

| 选项            | 含义                                                         |
| --------------- | ------------------------------------------------------------ |
| 文件1 -nt 文件2 | (new than) 判断文件1的修改时间是否比文件2的新                |
| 文件1 -ot 文件2 | (old than) 判断文件1的修改时间是否比文件2的旧                |
| 文件1 -ef 文件2 | (equal file) 判断文件1和文件2是否是同一个文件，可用于判断硬连接或符号链接，比如1.txt是2.txt的硬连接 |

**举例**

```shell
# 已有文件(夹)
-rw-r--r-- 1 root root 0 6月  22 17:55 1.txt
-rw-r--r-- 1 root root 0 6月  22 17:58 2.txt
drwxr-xr-x 2 root root 6 6月  22 17:56 a

# 注意：文件和文件夹之间也能对比


# 文件1.txt的修改时间是否比文件2.txt新
[ 1.txt -nt 2.txt ] && echo 'yes' || echo 'no' 
# 输出 
yes

# 文件1.txt的修改时间是否比文件夹a新
[ 1.txt -nt a ] && echo 'yes' || echo 'no' 
# 输出 
yes


```

### 6.1.5 两个整数之间的比较

| 选项            | 含义                                              |
| --------------- | ------------------------------------------------- |
| 整数1 -eq 整数2 | (equal) 判断整数1是否和整数2相等                  |
| 整数1 -ne 整数2 | (not equal) 判断整数1是否和整数2不相等            |
| 整数1 -gt 整数2 | (greater than)判断整数1是否大于整数2              |
| 整数1 -lt 整数2 | (less than)判断整数1是否小于整数2                 |
| 整数1 -ge 整数2 | (greater than or equal)判断整数1是否大于等于整数2 |
| 整数1 -le 整数2 | (less than  or equal)判断整数1是否小于等于整数2   |

**举例**

```shell
# 判断整数3是否小于整数4
[ 3 -lt 4 ] && echo 'yes' || echo 'no'
# 输出
yes
```



### 6.1.6 字符串的判断

| 选项               | 含义                           |
| ------------------ | ------------------------------ |
| -z 字符串          | 判断字符串是否为空             |
| -n 字符串          | 判断字符串是否为非空           |
| 字符串1 == 字符串2 | 判断字符串1是否和字符串2相等   |
| 字符串1 != 字符串2 | 判断字符串1是否和字符串2不相等 |

**举例**

```shell
a=哈哈
b=哈哈

# 判断变量a是否是一个空字符串
[ -z $a ] && echo 'yes' || echo 'no'
# 输出
no

# 判断变量a和变量b是否相等
[ $a == $b ] && echo 'yes' || echo 'no'
# 输出
yes
```

### 6.1.7 多重判断条件

* 可以多个条件
  * 判断1 -a 判断2 -a 判断3 等更多的判断

| 选项           | 含义         |
| -------------- | ------------ |
| 判断1 -a 判断2 | (and) 逻辑与 |
| 判断1 -o 判断2 | (or) 逻辑或  |
| !判断          | 逻辑非       |

**举例**

```shell
# 条件1和条件2都成立的话 输出yes 否则输出no
[ 2 -gt 1 -a  3 -gt 2 ] && echo 'yes' || echo 'no'
# 输出
yes

# 2 -gt 1的结果取反
[ ! 2 -gt 1 ] && echo 'yes' || echo 'no'
# 输出
no
```

## 6.2 单分支if语句

* `if`语句使用`fi`结尾
* [ 条件判断 ] 就是`test命令`进行判断
* then后面跟符合条件之后执行的程序



**语法**

```shell
# 使用;隔开
if [ 条件判断 ];then 代码体 fi

# 使用换行隔开就不需要写;
if [ 条件判断 ]
then
	代码体
fi
```

**举例**

a.sh

```shell
# !/bin/bash

# 使用;分隔写法
if [ 4 -gt 3 ];then echo 'bigger';fi

# 使用换行写法
if [ 3 -lt 4 ]
then
	echo smaller
fi
```

**判断当前用户是否是root用户**

isRoot.sh

```shell
# !/bin/bash

# 声明变量user值是系统变量whoami $() 用于调用系统变量
user=$(whoami)
if [ $user == root ]
then
	echo '是'
fi
```

## 6.3 双分支if语句

**语法**

```shell
if [ 条件判断 ]
then
	代码体1
else
	代码体2
fi
```

**举例**

isDir.sh

```shell
# !/bin/bash
# 判断输入的是否是一个文件夹
read -p 请输入一个路径 dir

if [ -d $dir ]
then
	echo $dir是一个路径
else
	echo $dir不是一个路径
fi

```

## 6.4 多分支语句

**语法**

```shell
if [ 条件判断 ]
then
	代码体1
elif [ 条件判断 ]
then
	代码体2
else 
	代码体3
fi
```

**举例**

score.sh

```shell
# !/bin/bash
# 根据输入的分数给出输出
read -p "请输入一个分数" score

if [ $score -gt 90 ]
then
	echo 优秀
elif [ $score -gt 80 ]
then
	echo 良好
else
	echo 差
fi

```

## 6.5 case语句

* case和if都是多分支判断语句，if能判断多个条件，case只能判断一个条件

**语法**

```shell
# *) 表示剩下的值和js的case的default一样
# 要以esac 就是case反过来
case $choice in
	值1)
		代码块1
		;;
	值2)
		代码块2
		;;
	*)
		代码块3
		;;
esac
```

**举例**

case.shell

```shell
# !/bin/bash
read -p "输入你的选择(yes/no/other)" choice

case $choice in
	yes)
		echo yes
		;;
	no)
		echo no
		;;
	*)
		echo other
		;;
esac
```

## 6.5 for循环

**语法**

```shell
for 变量 in 值1 值2 ... 值n
do
代码块
done

# 另一种
for (( 初始化; 条件; 迭代 ))
do
    代码块
done
```

**举例**

```shell
#!/bin/bash
for i in 1 2 3
do
	echo $i
done

# 还可以 效果和上面一样
for((i=1;i<=3;i++));
do
	echo $i;
done
```

## 6.6 while循环

* while循环是不定循环，也称为条件循环，只有判断条件成立，就会一直继续

**语法**

```shell
while [ 条件判断 ]
do
	代码块
done
```

**举例**

```shell
# !/bin/bash
# 结果是 打印1-9
i=1
while [ $i -lt  10 ]
do
	echo $i
	i=$(($i+1))
done

```

## 6.7 until循环

* 默认会执行do的代码块，直到条件成立停止

  

**语法**

```shell
until [ 条件判断 ]
do
	代码块
done
```

**举例**

```shell
# !/bin/bash
# 结果是 打印1-9
# 直到i>10才停止执行
i=1
until [ $i -gt  10 ]
do
	echo $i
	i=$(($i+1))
done

```

# 7 函数

* `Linux shell` 可以用户定义函数，然后在shell脚本中可以随便调用
* 可以使用`function`关键字定义，也可以`不使用`function定义
* 调用函数不需要加`()`

## 7.1 简单函数

**语法**

```shell
# []内表示可有可无
[function] funcName () {
	todo
	[return xxx]
}
```

**举例**

```shell
# !/bin/bash
function foo() {
	echo 123;
}

# 调用函数不需要加括号
foo


# 方式二 不使用function关键字定义
bar() {
	echo 123;
}
# 调用
bar


# 函数传参
# $1 $2 表示第一个参数和第二个参数 具体的看前面的笔记
bar() {
	echo $(($1+$2))
}
# 调用函数的时候 参数直接写后面
bar 2 3


```

## 7.2 return 返回值

* 参数返回，可以显示加return
* 如果不加return，将以最后一条命令的运行结果作为返回值

```shell
sum() {
	result=$(($1+$2))
	return $result
}

sum 2 3
echo $?
# 输入 5
```

## 7.3 参数说明

| 符号 | 作用                                                         |
| ---- | ------------------------------------------------------------ |
| $#   | 传递到脚本的参数个数                                         |
| $*   | 以一个单字符串显示所有向脚本传递的参数                       |
| $@   | 与$*相同，但是使用时加引号，并在引号中返回每个参数           |
| $$   | 脚本运行的当前的进程ID号                                     |
| $?   | 最后一次执行的命令的返回状态，0表示正确执行，非0表示不正确执行 |
