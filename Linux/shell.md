# 1 shell基础

* shell是一个命令行解释器，它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序
* 用户可以用Shell来启动、挂起、停止或编写一些程序
* Shell还是一个功能相当强大的编程语言，易编写，易调试，灵活性较强
* Shell是解释执行的脚本语言，在Shell中可以直接调用Linux的系统命令



## 1.1 echo

* 输出命令 类似js的console.log
* `-e`：激活转义符选项

```shell
# 输出hello
echo hello

# 添加-e 像\t \e这些都会被转义

# 下面输出结果是 a 换行之后输出 b
echo -e "a\nb"

# 下面输出结果是 a\nb 直接输出内容不会转义
echo "a\nb"
```

## 1.2 编写执行shell脚本

* shell脚本是以`.sh`结尾的文件
* 脚本文件内容必须以`#!/bin/bash`开头
* 执行文件使用 `sh 文件名`
* 不能直接以`./文件名`执行，因为默认创建的文件是没有执行权限的，需要`手动添加执行权限`才能这样执行

**举例**

```shell
# 编写一个 hello.sh文件
#!/bin/bash
echo hello
echo -e "a\tb"

# 执行 使用sh 进行执行
sh hello.sh
```

## 1.3 alias

* 此命令是用来`临时`给一个命令`起别名的`，当窗口关闭就会失效
* 删除别名使用`unalias 别名`即可

**案例**

```shell
# 想要给ls -a起一个别名为ls
# 这样只需输入 la 就相当于输入ls -a命令了
alias la="ls -a"


```



**永久生效方法**

* 想要永久生效需要修改`~/.bashrc`配置文件

**案例**

```shell
# 永久添加一个la别名 他表示的是ls -a命令
vi ~/.bashrc
# 然后添加如下命令
alias la="ls -a"

# 然后保存，然后输入如下命令使配置文件生效
source ~/.bashrc
#或者输入以下命令也可使配置文件生效
. ~/.bashrc
```

## 1.4 命令生效的顺序

**当在shell中输入命令按照以下的顺序查找**

* 绝对路径或相对路径
  * 比如输入/usr/bin/ls和ls这个命令的效果是一样的
* 别名
* bash内部的命令
* 按照`$PATH`环境变量定义的目录查找
  * $PATH中会定义几个目录
  * 查找的时候如果第一目录找不到就往后找，找到了就不往后继续找了

## 1.5 命令快捷键

| 命令   | 含义                       |
| ------ | -------------------------- |
| ctrl+c | 强制终止当前命令           |
| ctrl+l | 清屏，效果同clear命令      |
| ctrl+a | 光标移动到命令行首         |
| ctrl+e | 光标移动到命令行尾         |
| ctrl+u | 从光标所在的位置删除到行首 |

## 1.6 历史命令

**语法**

```shell
history [选项] [历史命令保存的文件]
```



**选项**

* -c 清空历史命令
* -w 把缓存中的历史命令写入对应的文件中一般是`~/.bash_history`

**案例**

```shell
# 查看所有的历史命令
history

# 清空历史命令
history -c

# 当我们在shell中输入过的命令 这些命令会在窗口关闭之后自动保存在~/.bash_history文件中
# 如果想要立马将命令保存进去输入下面的命令
history -w ~/.bash_history

# 或者想要将历史命令保存到别的文件中
history -w a.txt
```

## 1.7 调用 

* 使用该命令可以`执行历史命令中的某个命令`，历史命令中每条命令都有一个ID
* 使用`!n`执行历史命令中`第n条`(命令对应的数字)命令
* 使用`!!`执行上一条命令
* 使用`!字符`重复执行最后一条以该字符串开头的命令
* 在shell中输入`!`加上面说的规则，然后`回车`即可

**举例**

```shell
# 假设历史命令有如下几条
  991  ls
  992  touch a.txt
  993  clear
  994  ls
  995  vi a.txt 
  996  vi b.txt
  
# 执行第993条命令 命令行输入如下命令 然后和回车 就会继续执行第993条命令,也就是clear命令
!993

## 执行上一条命令，也就是vi b.txt
!!

# 执行vi命令
# 输入以下命令 会在历史命令中找到最后一个以v开头的命令 也就是vi b.txt这条命令 
!v 
```

## 1.8 输入输出重定向

* stdin 全拼 standard input(标准输入)
* stdout 全拼 standard out(标准输出)
* stderr 全拼 standard error(标准错误)

### 1.8.1 基本概念

* **标准输出（stdout）**：默认情况下，命令的输出会显示在屏幕上。这称为标准输出，通常`文件描述符为 1`。
* **标准错误（stderr）**：命令的错误消息默认情况下也显示在屏幕上。这称为标准错误，通常`文件描述符为 2`。
  * 比如输入`ls kk`这个命令，会报错 ，这就是标准错误

* **标准输入（stdin）**：命令的输入默认从键盘获取。这称为标准输入，通常`文件描述符为 0`。



### 1.8.2 输出重定向

#### 1.8.2.1  重定向符号

- 下面的都是，文件不存在将创建文件
- `>`：将标准输出重定向到一个文件。如果文件存在，将覆盖该文件。
- `>>`：将标准输出追加到一个文件末尾。如果文件不存在，将创建该文件。
- `2>`：将标准错误重定向到一个文件。如果文件存在，将覆盖该文件。
- `2>>`：将标准错误追加到一个文件末尾。如果文件不存在，将创建该文件。
- `&>`：将标准输出和标准错误一起重定向到一个文件。
- `&>>`：将标准输出和标准错误一起追加到一个文件末尾。

#### 1.8.2.2 常见用法示例

1. **将输出重定向到文件**：

   ```shell
   # 这会将 `ls` 命令的输出重定向到 `output.txt` 文件中。
   ls > output.txt
   ```

2. **将输出追加到文件**：

   ```shell
   # 这会将 `echo` 命令的输出追加到 `output.txt` 文件中，而不是覆盖它。
   echo "Hello, World!" >> output.txt
   ```

3. **将错误消息重定向到文件**：

   ```shell
   # 这会将 `ls` 命令的错误消息重定向到 `error.txt` 文件中。
   ls nonexistentfile 2> error.txt
   ```

   

4. **将输出和错误消息都重定向到同一个文件**：

   ```shell
   # 这会将 `ls` 命令的输出和错误消息都重定向到 `all_output.txt` 文件中。
   
   # 命令1
   ls > all_output.txt 2>&1
   
   # 命令2
   ls &> all_output.txt
   
   # 两个命令的作用都是相同的
   # 命令2 比较好理解  &> 表示将标准输出和标准错误一起重定向到一个文件 
   # 所以命令2就是ls命令无论是错或是对都重定向到all_output.txt中
   
   # 命令2是一个组合命令
   # 2>&1：将标准错误重定向到标准输出的位置。由于标准输出已经被重定向到 all_output.txt 文件，所以标准错误也会被重定向到同一个文件。
   # &1：表示将标准错误重定向到与标准输出相同的位置。 可以理解为引用标准输出的位置 在这个例子中也就是all_output.txt
   # 如果你只是使用 ls > all_output.txt，那么只有标准输出会被重定向到 all_output.txt，而标准错误仍然会显示在终端上。通过添加 2>&1，你确保标准错误也被重定向到同一个文件中，这样所有输出（包括错误消息）都记录在 all_output.txt 中。
   ```

5. **将命令的输出作为输入传递给另一个命令**：

   ```shell
   # 这会将 `ls` 命令的输出通过管道传递给 `grep` 命令，`grep` 会搜索包含 `pattern` 的行。
   ls | grep "pattern"
   ```

#### 1.8.2.3 示例应用

假设你想将一个程序的标准输出和标准错误都重定向到一个文件，你可以这样做：

```shell
./myprogram > output.txt 2>&1
```

或者更简单地使用 `&>`：

```shell
./myprogram &> output.txt
```

这样，程序的所有输出（包括错误消息）都会被记录到 `output.txt` 文件中。



### 1.8.3 标准输入的重定向

标准输入重定向允许你从文件或其他命令获取输入，而不是从键盘。常见的重定向操作符有：

- `<`：将标准输入重定向到一个文件。
- `<<`：将标准输入重定向到一个内联文档（heredoc）。
- `<<<`：将标准输入重定向到一个字符串（这里文档）。

#### 1.8.3.1 常见用法示例

1. **将文件作为标准输入**：

   ```shell
   command < inputfile
   ```

   例如，使用 `cat` 命令读取 `file.txt` 的内容：

   ```shell
   # 这与 `cat file.txt` 的效果相同，都是将 `file.txt` 的内容显示在终端上。
   cat < file.txt
   ```

2. **使用管道将一个命令的输出作为另一个命令的输入**：

   ```
   command1 | command2
   ```

   例如，将 `ls` 命令的输出传递给 `grep` 命令：

   ```shell
   # 这会在当前目录中搜索包含 `pattern` 的文件或目录。
   ls | grep "pattern"
   ```

   

3. **使用内联文档（heredoc）**：

   ```shell
   command << delimiter
   text
   delimiter
   ```

   例如，使用 `cat` 命令创建一个包含多行文本的文件：

   ```shell
   cat <<EOF > myfile.txt
   This is a line of text.
   This is another line of text.
   EOF
   ```

   这会将多行文本写入 `myfile.txt` 文件中，直到遇到 `EOF` 作为结束标志。

4. **使用字符串作为输入（here string）**：

   ```shell
   command <<< "string"
   ```

   例如，将字符串传递给 `wc` 命令以计算单词数量：

   ```shell
   wc -w <<< "Hello, world!"
   ```

   这会输出 `2`，表示字符串 "Hello, world!" 有两个单词。

#### 1.8.3.2  实际应用

假设你有一个需要从文件读取输入的命令，可以这样使用标准输入重定向：

1. **从文件读取输入**：

   ```shell
   sort < unsorted.txt
   ```

   这会将 `unsorted.txt` 文件的内容作为输入传递给 `sort` 命令，并输出排序后的结果。

2. **通过管道传递输入**：

   ```shell
   ps aux | grep "firefox"
   ```

   这会列出所有运行的进程，然后过滤出包含 "firefox" 的进程信息。

3. **内联文档创建文件**：

   ```shell
   cat <<EOF > example.txt
   Line 1
   Line 2
   Line 3
   EOF
   ```

   这会将多行文本写入 `example.txt` 文件中。

#### 1.8.3.3 总结

标准输入是命令读取数据的主要来源，默认是从键盘接收输入。通过重定向操作符 `<`、`<<` 和 `<<<`，可以将文件、字符串或其他命令的输出作为输入传递给命令，使得命令行操作更加灵活和强大。

## 1.9 多命令执行顺序

* 声明多个命令直接该怎么执行

| 多命令执行符 | 格式             | 作用                                                   | 案例              |
| ------------ | ---------------- | ------------------------------------------------------ | ----------------- |
| ;            | 命令1;命令2      | 多个命令执行，命令直接没有任何逻辑关系                 | echo 1;echo2      |
| &&           | 命令1 && 命令2   | 逻辑与，只有命令1执行正确才会执行命令2                 | echo 1 && echo2   |
| \|\|         | 命令1 \|\| 命令2 | 逻辑或，命令1执行失败会执行命令2，反之则 不会执行命令2 | echo 1 \|\| echo2 |

**举例**

```shell
# 使用;符号，即使前面的命令报错了也会执行后面的命令，因为命令之间没有任何关系
ls kk; echo 2

#  逻辑与操作 和js差不多
echo 1 && echo 2

#  逻辑或操作 和js差不多
echo 1 || echo 2
```

## 1.10 管道符号

* 符号为：`|` 
* `｜前`的命令的`执行结果`会作为`｜之后`命令的`输入`

**案例**

```shell
# 假设1.txt有两行 第一行是123 第二行是456
# cat 1.txt的结果会作为 tail -1的输入
# 结果就是显示456
cat 1.txt | tail -1
```

## 1.11 通配符

| 通配符 | 作用                                                 |
| ------ | ---------------------------------------------------- |
| ?      | 匹配一个任意字符                                     |
| *      | 匹配0个或多可任意字符                                |
| []     | 匹配中括号中的任意一个                               |
| [-]    | 匹配中括号中的范围任意一个 eg:[0-9]匹配0-9中任意一个 |
| [^]    | 匹配不是中括号中的任意字符                           |

## 1.12 其他符号

| 符号  | 作用                                                         |
| ----- | ------------------------------------------------------------ |
| ''    | 单引号，在单引号中所有特殊符号，如`$`和`` `都没有特殊含义    |
| ""    | 双引号，在双引号中所有特殊符号都没有特殊含义，但是$  `  \这3个例外，拥有调用变量的值，引用命令和转义的含义 |
| \` \` | 反引号，括起来的是系统命令                                   |
| $()   | 和反引号一样                                                 |
| #     | 在shell脚本中，#开头的行代表注释                             |
| $     | 用于调用变量的值                                             |
| \     | 转义符号                                                     |

**举例**

```shell
# 输出结果就是$PATH
echo '$PATH'

# 输出结果 PATH这个变量的值 也就是当前系统环境变量有哪些
echo "$PATH"

# 输出 ls这个系统命令的执行结果
echo `ls`

```

# 2 变量

## 2.1 变量命名规则

* 必须以字母或下划线开头，名字中间只能由字母，数字和下划线组成
* 变量名的长度不得超过255个字符
* 变量名在有效范围内必须唯一
* 变量`默认类型都是字符串`

## 2.2 变量的类型

* 字符串
* 整型
* 浮点型
* 日期型

## 2.3 用户自定义变量

* 变量名不能以数字开头
* 等号左右两边不能有空格

### **定义变量**

```shell
# 注意 虽然age的值是10 但是他的类型依然是字符串类型
name="zs"
age=10
```

### **输出变量**

* 使用`$`调用变量

```shell
echo $name
echo $age
```

### **值默认都是字符串**

```shell
x=1
y=2
z=$x+$y

# 输出的结果是 1+2 所以可以证明值默认是字符串类型
echo $z

```

### 在赋值的时候引用变量

```shell
# 可以在双引号中之间调用变量
# 也可以使用 ${x} 调用变量 
x=123
y="$x"4
z=0${x}
```

### set

* 查询系统中默认所有已生效的变量，包括系统变量、环境变量，也包括自定义的变量

```shell
set

# 只查询有name的变量
set | grep name
```

### unset

* 删除变量
* unset 变量名

```shell
# 删除name这个变量
unset name
```

## 2.4 环境变量

* 环境变量是`全局变量`，自定义变量是`局部变量`
* `自定义变量`会在`当前shell中生效`，而环`境变量`会在`当前shell以及其子shell中生效`
  * 在shell中输入`bash`命令即可进入一个子shell
* 这种变量主要保存的是和系统操作环境相关的数据
* 环境变量可以自定义，但是`对系统生效的环境变量名`和`变量作用是固定的`

### 自定义环境变量

* 使用export关键字 `export 变量名=变量值`
* 这种方式只能临时创建系统变量，当shell关闭或者新打开一个shell就会没了
* 想要永久生效，需要修改文件

```shell
export name=zs
```

### env

* 仅仅用来查看环境变量，而看不到本地变量

```shell
# 查看所有的环境变量
env

# 查看环境变量中name相关的环境变量
env | grep name
```

### 常见的环境变量

| 变量名     | 含义                                                         |
| ---------- | ------------------------------------------------------------ |
| HOSTNAME   | 主机名                                                       |
| SHELL      | 当前的shell,LINUX中的终端有很多种,这个命令就是查看当前用的哪一种终端 |
| HISTSIZE   | 历史命令条数                                                 |
| SSH_CLIENT | 当前操作环境如果是用ssh连接的话，这里会记录客户端的IP        |
| USER       | 当前登录的用户                                               |

```shell
echo $HOSTNAME
echo $SHELL
echo $HISTSIZE
echo $SSH_CLIENT
echo $USER
```

### PATH

* `系统搜索的路径`
* 具体看上面`命令生效顺序章节`

```shell
 echo $PATH
 /root/.nvm/versions/node/v16.15.1/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin
```

**如何可以让一个自定义的脚本可以直接执行**

```shell
# 现在有hello.sh这个脚本 想让他在全局任意位置可以执行
# 也就是直接输入hello.sh可直接执行

# 方式一
# 把这个文件拷贝到 $PATH的其中任意目录下
# 比如/root/bin
# 原理：这个命令执行的顺序是从$PATH这一堆路径中查找的，找到了就执行


# 方式二 
# 把脚本文件所在的目录添加到PATH变量中
# 假如这个脚本文件在 /root/shells下面
# 注意linux中路径直接到分隔符用 :
export PATH="$PATH":/root/shells
```

### 语系环境变量

* 查询当前系统语系
* 在Linux中通过`locale命令`来设置程序运行的不同语言环境
* locale由ANSI C提供支持
* `LANG：定义系统主语系的变量`

```shell
# locale的命令规则为<语言>_<地区>.<字符集编码>
# 如 zh_CN.UTF-8
# zh表示中文。CN表示大陆地区 UTF-8表示字符集

# 查询当前系统语系
locale

# 查询当前系统主语系
echo $LANG
```

### 中文支持

* 图像界面可以支持中文
* 第三方工具比如xshell语系设置正确可以支持中文
* 虚拟机中纯字符界面不支持中文

## 2.5 参数位置变量

* 这种变量主要是用来获取脚本执行时传入的参数或者数据的
* 变量名不能自定义，变量的作用也是固定的

| 变量名 | 作用                                                         |
| ------ | ------------------------------------------------------------ |
| $n     | n是数字，$0表示命令本身，$1-9表示第1到第9个参数，10以上的参数需要用大括号包含,如${10} |
| $*     | 获取命令中所有参数，但是把所有参数当作一个整体               |
| $@     | 获取命令中所有参数，但是把所有参数进行区分，类似js的arguments |
| $#     | 获取所有参数的个数                                           |

**举例**

sum.sh

```shell
#!/bin/bash
# 获取传入的第一个参数和第二个参数的和
x=$1
y=$2
sum=$(($1+$2))
echo $sum

# 执行该文件 输出结果为7
sh sum.sh 3 4
```

```shell
# $* 
# 比如输入如下
sh for.sh 1 2 3
# $*  会将1 2 3看作是一个整体
# 那么进行循环的时候也只会执行一次

# $@ 会将1 2 3拆分
# 如果进行循环 那么就会执行三次



```

## 2.6 预定义变量

* 脚本中已经定义好的变量，变量名不能自定义，作用也是固定的

| 变量名 | 作用                                                         |
| ------ | ------------------------------------------------------------ |
| $?     | 最后一次执行的命令的返回状态，0表示正确执行，非0表示不正确执行 |
| $$     | 当前进行的进程号(PID)                                        |

```shell
# $?
# 假如我执行 ls 命令
# 然后 输入 echo $? 可以查看ls的执行结果
echo $?

```

## 2.7 read

* 和用户交互用的命令

**语法**

```shell
read [选项] [变量名]
```

**选项**

* `-p` 提示信息，在等待read输入时，输出提示信息
* `-t`  秒数：read命令会已知等待用户输入，使用此选项可以指定等待时间
* `-n`  字符数，read命令只接受指定的字符数就会执行
* `-s`  隐藏输入的数据，适用于机密信息的输入

**举例**

read.sh

```shell
#!/bin/bash

# 注意每个交互输入完毕之后 按回车进行下一步
# -t 3 如果3秒之后还没有输入 就会跳过当前交互 执行下一个交互 那么对应的name这个变量的值也是空的
# -p '信息' 表示给用户信息提示
read -p 请输入姓名 -t 3 name
echo -e '\n'
# -n 1 指定用户输入的字数只有1个 当输入一个之后不用按回车 会自动的执行下一个交互
read -p 请输入性别[男/女] -n 1 sex
echo -e '\n'
# -s 输入的时候不显示出来
read -p  请输入密码 -s  passwd
echo -e '\n'
echo $name $sex $passwd

# 在shell 中输入 sh read.sh即可执行
```

# 3 运算符

* shell语言是弱类型的语言
* 且默认声明的变量是字符串类型

## 3.1 declare

* 用于声明变量的类型

| 选项 | 含义                 |
| ---- | -------------------- |
| -    | 给变量设定类型属性   |
| +    | 取消变量的类型属性   |
| -a   | 将变量声明为属组类型 |
| -i   | 将变量声明为整数类型 |
| -x   | 将变量声明为环境变量 |
| -r   | 将变量声明为只读变量 |
| -p   | 显示变量被声明的类型 |

**举例**

```shell
# - 和 +  后面都可以跟a、i、x、r

# 可以使用declare声明带类型的变量
# 也可以给已声明的类型增加或者取消变量类型属性
# 一旦设置变量为只读类型将无法使用+r取消只读类型

# 案例一
# 声明变量a、b 声明变量c是a+b的值
# 默认情况下c的值是1+2 因为变量默认情况下是字符串类型的
 a=1
 b=2
 c=$a+$b
 echo $c  # 1+2
# 只需要这样声明就行
# 表示声明一个变量c类型是整型
declare -i c=$a+$b
echo $c # 3

# 案例2 取消变量x的整型类型
#声明一个变量x 类型是整型
declare -i x=1
# 显示x的类型
declare -p x # declare -i x="1"

#取消x的整型类型
declare +i x
# 显示x的类型
declare -p x # declare -- x="1"
```

**数组**

```shell
# 声明为数组类型
declare -a names

# 给数组赋值
names[0]=zhangsan
names[1]=lisi

# 默认只打印第一个元素
# 直接输出names 只打印第一个元素 
# echo $names 相当于 echo ${names[0]}
echo $names # zhangsan

# 打印第二个元素 
echo ${names[1]}  # lisi

# 打印全部元素
echo ${names[*]} # zhangsan lisi

# 什么时候使用 ${} 调用变量

# 当输出的变量作为一个整体的时候使用`${变量}`输出
# 比如想要打印names的第一个元素
# 使用$names[0]
# 这是错误的因为会把$names当作一个整体然后打印zhangsan[0] zhangsan不是一个变量所以结果就是zhangsan[0]
echo $names[0] # zhangsan[0]

# 正确做法是
echo ${names[0]} # zhangsan 


```



**声明环境变量**

* `export`命令声明的环境变量 最终执行的是`declare -x`命令

```shell
# 案例 设置kk为环境变量
declare -x kk=3

# 查询一下是否设置成功
env | grep kk  # kk=1
```

## 3.2 数值运算的方法

* 方法比较多 看案例

```shell
num1=1
num2=2

# 方式一
# 注意+两边必须要有空格
sum=$(expr $num1 + $num2)
echo $sum #3

# 方式二
# 使用小括号将$num1和$num2作为一个整体
sum1=$(($num1+$num2))
echo $sum1 #3

# 方式三
sum2=$[$num1+$num2]
echo $sum2 #3

# 方式四
declare -i sum3=$num1+$num2
echo $sum3 #3
```

## 3.3 优先级

* 让gpt帮忙生成

# 4 环境变量配置文件

## 4.1 source

* 修改完配置文件后，必须注销重新登录，配置文件才能生效
* 使用source命令，`可以直接让修改过的配置文件生效`

**案例**

```shell
# 假如修改了 bash_profile配置文件
# 在不注销的情况下使配置文件生效

# 方式一 使用source命令
source bash_profile

# 方式二 使用 . 直接执行当前文件
. bash_profile
```

## 4.2 环境变量配置文件简介

* 环境变量配置文件中，主要是`定义系统操作环境生效的系统默认环境变量`
* PATH、HISTSIZE、PS1、HOSTNAME等环境变量写入对应的环境配置文件

| 路径            | 说明               |
| --------------- | ------------------ |
| /etc/profile    | 针对所有的用户生效 |
| /etc/bashrc     | 针对所有的用户生效 |
| ~/.bash_profile | 只会对当前用户生效 |
| ~/.bashrc       | 只会对当前用户生效 |

## 4.3 环境变量配置文件的功能

### **/etc/profile**

* 在这里修改`系统变量`
* 这个文件`针对所有的shell生效的`

| 变量名   | 含义     |
| -------- | -------- |
| USER     | 用户名   |
| LOGNAME  | 登录名   |
| MAIL     | 邮箱地址 |
| PATH     | 查找路径 |
| HOSTNAME | 主机名   |
| umask    | 权限掩码 |

### **~/.bash_profile**

* 在这里修改`PATH`路径
* 这个文件只`针对当前用户的shell生效`

### **/etc/bashrc**

* shell有很多的类型，比如bashsehll、zhshell等等
* 这个文件`针对的是所有的bash shell生效的`

### **~/.bashrc**

* 这个文件针对的是`当前用户的bash shell生效的`
* 这里修改别名，配置alias



###  其他配置文件

**～/.bash_logout**

* 注销时生效的环境变量配置文件
* 当注销时，会执行这个配置文件



**~/.bash_history**

* 当正确退出计算机时候，会把历史记录写入改文件



**Shell登录信息**

* 当登录的时候会执行的配置文件
* 本地终端欢迎信息`/etc/issue`
* 远程终端欢迎信息`/etc/issue.net`
* 本地和远程都生效`/etc/motd`

| 参数 | 含义                       |
| ---- | -------------------------- |
| /d   | 当前系统日期               |
| /s   | 显示操作系统名称           |
| /l   | 显示登录的终端号           |
| /m   | 显示硬件体系结构           |
| /n   | 显示主机名                 |
| /o   | 显示域名                   |
| /r   | 显示内核版本               |
| /t   | 显示当前系统时间           |
| /u   | 显示当前登录的用户名序列号 |



# 5

## 5.1 cut

* cut用来提取文本中的某一部分文本
* 语法 `cut [选项] 文件名或内容`
* 选项
  * `-f `列号，用来指定分隔第几列的数据
  * `-d` 分隔符，被分割的文本以什么符号为规律进行分隔

**举例**

```shell
# demo.txt的内容如下
i-1-2-r-c
w-1-2-r-c
q-1-2-r-c

# 现在需要提取的是第一列和最后一列的数据
# 可以看到都是以-进行分隔的，所以-d就写-
# 这样-f才能正确的采集到列号
cut -f 1,5 -d -

# 输出结果
i-c
w-c
q-c

```

## 5.2 printf

* 用于格式化并输出文本

* 语法：`printf 输出格式 填充内容`

* rintf 不会像 **echo** 自动添加换行符，我们可以手动添加 **\n**。

* 只列举部分使用 用到的时候可以去查[链接](https://www.runoob.com/linux/linux-shell-printf.html#:~:text=printf%20%E5%91%BD%E4%BB%A4%E6%A8%A1%E4%BB%BF%20C%20%E7%A8%8B%E5%BA%8F%E5%BA%93%EF%BC%88library%EF%BC%89%E9%87%8C%E7%9A%84%20printf%20%28%29%20%E7%A8%8B%E5%BA%8F%E3%80%82%20printf,printf%20%E7%9A%84%E8%84%9A%E6%9C%AC%E6%AF%94%E4%BD%BF%E7%94%A8%20echo%20%E7%A7%BB%E6%A4%8D%E6%80%A7%E5%A5%BD%E3%80%82%20printf%20%E4%BD%BF%E7%94%A8%E5%BC%95%E7%94%A8%E6%96%87%E6%9C%AC%E6%88%96%E7%A9%BA%E6%A0%BC%E5%88%86%E9%9A%94%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%8C%E5%A4%96%E9%9D%A2%E5%8F%AF%E4%BB%A5%E5%9C%A8%20printf%20%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E8%BF%98%E5%8F%AF%E4%BB%A5%E5%88%B6%E5%AE%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%AE%BD%E5%BA%A6%E3%80%81%E5%B7%A6%E5%8F%B3%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F%E7%AD%89%E3%80%82)

  

**参数说明**

| 参数       | 含义                            |
| ---------- | ------------------------------- |
| %ns        | 输出字符串，n表示输出几个字符串 |
| %nd 或 %ni | 输出整数，n表示输出多少个整数   |
|            |                                 |

**举例**

```shell
# 
printf "%-10s %-8s %-4s\n" 姓名 性别 体重kg

# 输出结果
# -10s 指一个宽度为 10 个字符（- 表示左对齐，没有则表示右对齐），任何字符都会被显示在 10 个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。
# 对应的填充内容是姓名 所以算上姓名这两字还会输出8个空格 加起来一共10个字
# -8s 输出一个宽为8的字符 算上性别填充两个字符还要输出6个空格
# -4s 输出一个宽为4的字符 体重kg正好是4个字符
# \n 换行符。输出这些后会换行继续输出
姓名        性别      体重kg


# 假设有一个a.txt 内容如下 格式是没有规律的
# 所以就无法用cut命令来切割想要的内容了
# 可以使用printf先格式化 然后在切割
姓名   性别 体重kg 
 郭靖 男   66.1234
杨过 男   48.6543
郭芙  女 47.9876 

# $(cat a.txt) 可以拿到执行后的内容
# %s- 表示填充内容后面是-隔开
printf "%s-%s-%s\n" $(cat a.txt)
# 输出结果 这样就规律了 
姓名-性别-体重kg
郭靖-男-66.1234
杨过-男-48.6543
郭芙-女-47.9876

#使用cut配合使用
printf "%s-%s-%s\n" $(cat a.txt) | cut -d - -f 1,2
# 执行结果
姓名-性别
郭靖-男
杨过-男
郭芙-女
```

